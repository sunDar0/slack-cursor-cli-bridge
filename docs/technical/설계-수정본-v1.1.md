# **Golang ê¸°ë°˜ Slack-Cursor-CLI ì—°ë™ ì„œë²„: ìš´ì˜-ìˆ˜ì¤€ ì•„í‚¤í…ì²˜ ë° ë³´ì•ˆ ì„¤ê³„ ë³´ê³ ì„œ (v1.1)**

> **ìˆ˜ì • ì´ë ¥:**
> - v1.0: ì´ˆê¸° ì„¤ê³„ (2024)
> - v1.1: cursor-cli ì‹¤ì œ ë™ì‘ ë°©ì‹ ë°˜ì˜ (2025-01)
>   - cursor-agentì˜ `--files` í”Œë˜ê·¸ ë¯¸ì§€ì› í™•ì¸
>   - `--force` í”Œë˜ê·¸ ì¶”ê°€ í•„ìš”ì„± íŒŒì•…
>   - ìì—°ì–´ í”„ë¡¬í”„íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ë¡œ ì¬ì„¤ê³„

## **I. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜: ìš´ì˜-ìˆ˜ì¤€ì˜ ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì²˜ë¦¬ê¸°**

### **A. ì´ˆê¸° ì•„í‚¤í…ì²˜ì˜ ìœ„í—˜ì„± ë¶„ì„: ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ**

ì´ˆê¸° ê¸°ìˆ  ëª…ì„¸ëŠ” Slack ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ(Slash Command) ìš”ì²­ì„ ìˆ˜ì‹ í•  ë•Œë§ˆë‹¤ `go runCursorTask(payload)`ë¥¼ í˜¸ì¶œí•˜ì—¬ ìƒˆë¡œìš´ Goroutineì„ ìƒì„±í•˜ëŠ” ëª¨ë¸ì„ ì œì•ˆí•©ë‹ˆë‹¤. ì´ ì•„í‚¤í…ì²˜ëŠ” ê¸°ëŠ¥ì ìœ¼ë¡œëŠ” ë™ì‘í•˜ì§€ë§Œ, ìš´ì˜ í™˜ê²½ì—ì„œëŠ” ì‹¬ê°í•œ ì•ˆì •ì„± ìœ„í—˜ì„ ë‚´í¬í•©ë‹ˆë‹¤.

`os/exec`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì™¸ë¶€ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹¤í–‰í•˜ëŠ” ì‘ì—…ì€ Go ëŸ°íƒ€ì„ì—ì„œ ë¹„ìš©ì´ ë§¤ìš° ë†’ì€ ì‘ì—…ì…ë‹ˆë‹¤. íŠ¹íˆ, ìì‹ í”„ë¡œì„¸ìŠ¤ì˜ ì¢…ë£Œë¥¼ ê¸°ë‹¤ë¦¬ëŠ” `cmd.Wait()` í˜¸ì¶œì€ Go ëŸ°íƒ€ì„ì´ í•´ë‹¹ ëŒ€ê¸°ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ìƒˆë¡œìš´ OS ìŠ¤ë ˆë“œ(Thread)ë¥¼ ìƒì„±í•˜ë„ë¡ ê°•ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê° ìŠ¤ë ˆë“œëŠ” ì»¤ë„ ë¦¬ì†ŒìŠ¤ì™€ ìƒë‹¹í•œ í¬ê¸°ì˜ ìŠ¤íƒ ë©”ëª¨ë¦¬(ì˜ˆ: 2MB)ë¥¼ ì†Œë¹„í•©ë‹ˆë‹¤.

ë§Œì•½ Slackì—ì„œ ì§§ì€ ì‹œê°„ ë‚´ì— ë§ì€ ìˆ˜ì˜ ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ìš”ì²­ì´ í­ì£¼(Thundering Herd)í•  ê²½ìš°, ì´ ì•„í‚¤í…ì²˜ëŠ” í†µì œ ì—†ì´ ìˆ˜ë°±, ìˆ˜ì²œ ê°œì˜ Goroutineê³¼ OS ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê²Œ ë©ë‹ˆë‹¤. ì´ëŠ” ê²°êµ­ ì„œë²„ì˜ ë©”ëª¨ë¦¬ ê³ ê°ˆ(Out-of-Memory, OOM), ìŠ¤ë ˆë“œ í•œê³„ ë„ë‹¬, ë˜ëŠ” ê³¼ë„í•œ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜(GC) ì••ë ¥ìœ¼ë¡œ ì´ì–´ì ¸ ì „ì²´ ì„œë¹„ìŠ¤ê°€ ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•˜ê²Œ ì¤‘ë‹¨(Crash)ë˜ëŠ” ê²°ê³¼ë¥¼ ì´ˆë˜í•©ë‹ˆë‹¤. ì´ëŠ” ì‹œìŠ¤í…œì˜ ëª…ë°±í•œ ì¥ì•  ì§€ì (Single Point of Failure)ì…ë‹ˆë‹¤.

### **B. ì œì•ˆ ì•„í‚¤í…ì²˜: 'Job Queue -> Dispatcher -> Worker Pool'**

ì´ëŸ¬í•œ ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ ì·¨ì•½ì ì„ ê·¼ë³¸ì ìœ¼ë¡œ í•´ê²°í•˜ê¸° ìœ„í•´, ë³¸ ë¬¸ì„œëŠ” HTTP ìš”ì²­ ìˆ˜ì‹ (Gin)ê³¼ ê³ ë¹„ìš© ì‘ì—… ì‹¤í–‰(`os/exec`)ì„ ì™„ì „íˆ ë¶„ë¦¬(Decoupling)í•˜ëŠ” **ì‘ì—…ì í’€(Worker Pool) ì•„í‚¤í…ì²˜**ë¡œì˜ ì „ë©´ì ì¸ ì¬ì„¤ê³„ë¥¼ ì œì•ˆí•©ë‹ˆë‹¤. ì´ ëª¨ë¸ì€ ì‹œìŠ¤í…œì´ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ë™ì‹œ `os/exec` ì‘ì—… ìˆ˜ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì œì–´í•˜ì—¬, ìš”ì²­ëŸ‰ì— ê´€ê³„ì—†ì´ ì‹œìŠ¤í…œì˜ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ë¥ ì„ ì•ˆì •ì ìœ¼ë¡œ ìœ ì§€í•©ë‹ˆë‹¤.

ì°¸ê³ í•œ ê³ ì„±ëŠ¥ í ì•„í‚¤í…ì²˜ì— ê¸°ë°˜í•˜ì—¬, ì‹œìŠ¤í…œì€ ë‹¤ìŒ ì„¸ ê°€ì§€ í•µì‹¬ êµ¬ì„± ìš”ì†Œë¡œ ì¬í¸ë©ë‹ˆë‹¤:

1. **Job Queue (chan Job):** ëª¨ë“  ìˆ˜ì‹  ì‘ì—…ì„ ë³´ê´€í•˜ëŠ” ì¤‘ì•™ ë²„í¼ ì±„ë„(Buffered Channel)ì…ë‹ˆë‹¤. Gin í•¸ë“¤ëŸ¬ëŠ” ì‘ì—…ì„ ì´ íì— ì¶”ê°€í•˜ê³  ì¦‰ì‹œ ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.
2. **Dispatcher:** ì‘ì—…ì í’€ì„ ì´ê´„ ê´€ë¦¬í•©ë‹ˆë‹¤. Job Queueì—ì„œ ì‘ì—…ì„ ê°€ì ¸ì™€ í˜„ì¬ ìœ íœ´(Idle) ìƒíƒœì¸ Workerì—ê²Œ ì‘ì—…ì„ ë¶„ë°°(Dispatch)í•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.
3. **Worker Pool:** ì‹œìŠ¤í…œì˜ ìµœëŒ€ ë™ì‹œì„±ì„ ì œì–´í•˜ê¸° ìœ„í•´ *ê³ ì •ëœ ìˆ˜*(ì˜ˆ: N=5)ì˜ Worker Goroutineì„ ë¯¸ë¦¬ ìƒì„±í•˜ì—¬ ì‹¤í–‰í•©ë‹ˆë‹¤. ê° WorkerëŠ” Dispatcherë¡œë¶€í„° ì‘ì—…ì„ í• ë‹¹ë°›ì•„ cursor-agent ì‹¤í–‰ì´ë¼ëŠ” ì‹¤ì œ ì‘ì—…ì„ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.

ì´ ì•„í‚¤í…ì²˜ëŠ” ë™ì‹œì— ì‹¤í–‰ë˜ëŠ” `os/exec`ì˜ ìµœëŒ€ ê°œìˆ˜ë¥¼ Nê°œ(Workerì˜ ìˆ˜)ë¡œ ì—„ê²©í•˜ê²Œ ì œí•œí•˜ì—¬, ìŠ¤ë ˆë“œ ë° ë©”ëª¨ë¦¬ ê³ ê°ˆ ë¬¸ì œë¥¼ ì›ì²œì ìœ¼ë¡œ ë°©ì§€í•©ë‹ˆë‹¤.

### **C. ê³ ë„í™”ëœ ë°ì´í„° íë¦„ (ì¬ì •ì˜)**

1. **[ì‚¬ìš©ì]** ì‚¬ìš©ìê°€ `/cursor "main.goì˜ ë²„ê·¸ë¥¼ ìˆ˜ì •í•´ì¤˜"`ë¥¼ ì…ë ¥í•©ë‹ˆë‹¤.
2. **[Gin]** `POST /slack/cursor` ì—”ë“œí¬ì¸íŠ¸ê°€ ìš”ì²­ì„ ìˆ˜ì‹ í•©ë‹ˆë‹¤.
3. **[Middleware]** `SlackAuthMiddleware`ê°€ ìš”ì²­ì˜ HMAC ì„œëª…ê³¼ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
4. **[Handler]** `handleSlashCursor` í•¸ë“¤ëŸ¬ê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.
   * Slackì— 3ì´ˆ ì´ë‚´ì— ì¦‰ê°ì ì¸ 200 OK (ACK) ì‘ë‹µì„ ì „ì†¡í•©ë‹ˆë‹¤.
   * ìš”ì²­ í˜ì´ë¡œë“œë¡œ Job ê°ì²´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
   * ìƒì„±ëœ Jobì„ `Dispatcher.JobQueue <- newJob`ì„ í†µí•´ ì¤‘ì•™ ì‘ì—… íì— ì „ì†¡í•©ë‹ˆë‹¤.
5. **[Dispatcher]** (ë°±ê·¸ë¼ìš´ë“œ Goroutineì—ì„œ ì‹¤í–‰)
   * `JobQueue`ì—ì„œ `newJob`ì„ ìˆ˜ì‹ í•©ë‹ˆë‹¤.
   * Worker Poolì—ì„œ ìœ íœ´ ì‘ì—…ì(Worker)ì˜ ì‘ì—… ì±„ë„ì„ ëŒ€ê¸°í•©ë‹ˆë‹¤.
   * `selectedWorker.WorkChannel <- newJob`ìœ¼ë¡œ ì‘ì—…ì„ í• ë‹¹í•©ë‹ˆë‹¤.
6. **[Worker]** (ë°±ê·¸ë¼ìš´ë“œ Goroutine, Nê°œ ì¤‘ í•˜ë‚˜)
   * `job := <- WorkChannel`ì„ í†µí•´ ì‘ì—…ì„ ìˆ˜ì‹ í•©ë‹ˆë‹¤.
   * `TaskExecutor.Run(job)`ì„ í˜¸ì¶œí•˜ì—¬, **íŒŒì‹± -> ë³´ì•ˆ ê²€ì¦ -> os/exec ì‹¤í–‰ -> íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬**ì˜ ì „ì²´ íŒŒì´í”„ë¼ì¸ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
   * ì‹¤í–‰ ì™„ë£Œ í›„, `sendDelayedResponse`ë¥¼ í˜¸ì¶œí•˜ì—¬ Slack response_urlë¡œ ê²°ê³¼ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤.
7. **[Slack]** (SSRF ê²€ì¦ í†µê³¼ í›„) ì‚¬ìš©ìê°€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì „ì†¡ëœ cursor-agent ì‹¤í–‰ ê²°ê³¼ë¥¼ ì±„ë„ì—ì„œ í™•ì¸í•©ë‹ˆë‹¤.

## **II. Cursor CLI ë™ì‘ ë°©ì‹ ë° ì•„í‚¤í…ì²˜ ì ì‘**

### **A. Cursor Agent CLIì˜ ì‹¤ì œ ë™ì‘ ì›ë¦¬**

cursor-agentëŠ” ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì§•ì„ ê°€ì§„ AI ì½”ë”© ë„êµ¬ì…ë‹ˆë‹¤:

#### **1. í”„ë¡œì íŠ¸ ì „ì²´ ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜**

cursor-agentëŠ” **ê°œë³„ íŒŒì¼ ì§€ì •ì´ ì•„ë‹Œ í”„ë¡œì íŠ¸ ì „ì²´**ë¥¼ ì»¨í…ìŠ¤íŠ¸ë¡œ ì‘ë™í•©ë‹ˆë‹¤:

```bash
# âœ… ì˜¬ë°”ë¥¸ ì‚¬ìš©ë²•: ìì—°ì–´ í”„ë¡¬í”„íŠ¸
cursor-agent -p "main.goì˜ ë²„ê·¸ë¥¼ ìˆ˜ì •í•´ì¤˜"
cursor-agent -p "auth ëª¨ë“ˆì„ JWT í† í° ë°©ì‹ìœ¼ë¡œ ë¦¬íŒ©í† ë§í•´ì¤˜"

# âŒ ì˜ëª»ëœ ê°€ì •: --files í”Œë˜ê·¸ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠìŒ
cursor-agent -p "fix bug" --files main.go utils.go  # ì˜¤ë¥˜!
```

**ì‘ë™ ë©”ì»¤ë‹ˆì¦˜:**
- cursor-agentëŠ” ì‹¤í–‰ ë””ë ‰í† ë¦¬(`cmd.Dir`)ì˜ ëª¨ë“  íŒŒì¼ì„ ìŠ¤ìº”
- AIê°€ í”„ë¡¬í”„íŠ¸ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ ê´€ë ¨ íŒŒì¼ì„ ìë™ìœ¼ë¡œ ì‹ë³„
- ì‚¬ìš©ìëŠ” í”„ë¡¬í”„íŠ¸ì— íŒŒì¼ëª…ì„ ìì—°ì–´ë¡œ ì–¸ê¸‰í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì˜ë„ ì „ë‹¬

#### **2. ê¶Œí•œ ì‹œìŠ¤í…œ (Permissions)**

cursor-agentëŠ” `.cursor/cli.json` ë˜ëŠ” `~/.cursor/cli-config.json`ì— ì •ì˜ëœ ê¶Œí•œ ì‹œìŠ¤í…œì„ ì‚¬ìš©í•©ë‹ˆë‹¤:

```json
{
  "version": 1,
  "permissions": {
    "allow": [
      "Read(src/**/*.go)",
      "Write(src/**/*.go)",
      "Shell(git)",
      "Shell(go)"
    ],
    "deny": [
      "Write(**/.env*)",
      "Write(**/*.key)",
      "Shell(rm)"
    ]
  }
}
```

**ê¶Œí•œ íƒ€ì…:**
- `Read(pathOrGlob)`: íŒŒì¼ ì½ê¸° ê¶Œí•œ
- `Write(pathOrGlob)`: íŒŒì¼ ì“°ê¸° ê¶Œí•œ
- `Shell(commandBase)`: ì‰˜ ëª…ë ¹ ì‹¤í–‰ ê¶Œí•œ

#### **3. ë¹„ëŒ€í™”í˜• ëª¨ë“œ (Non-Interactive Mode)**

ì„œë²„ í™˜ê²½ì—ì„œëŠ” `-p, --print` í”Œë˜ê·¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹„ëŒ€í™”í˜•ìœ¼ë¡œ ì‹¤í–‰í•©ë‹ˆë‹¤:

```bash
# ê¸°ë³¸ í…ìŠ¤íŠ¸ ì¶œë ¥
cursor-agent -p "í”„ë¡¬í”„íŠ¸" --output-format text

# JSON ì¶œë ¥ (íŒŒì‹± ê°€ëŠ¥)
cursor-agent -p "í”„ë¡¬í”„íŠ¸" --output-format json

# ìŠ¤íŠ¸ë¦¬ë° JSON (ì‹¤ì‹œê°„ ì§„í–‰ ì¶”ì )
cursor-agent -p "í”„ë¡¬í”„íŠ¸" --output-format stream-json
```

**ì¤‘ìš”: `--force` í”Œë˜ê·¸**

`--print` ëª¨ë“œëŠ” **ê¸°ë³¸ì ìœ¼ë¡œ ì½ê¸° ì „ìš©**ì…ë‹ˆë‹¤. íŒŒì¼ ìˆ˜ì •ì„ í—ˆìš©í•˜ë ¤ë©´ `--force` í”Œë˜ê·¸ê°€ í•„ìˆ˜ì…ë‹ˆë‹¤:

```bash
# âŒ íŒŒì¼ ìˆ˜ì • ë¶ˆê°€ (ì œì•ˆë§Œ ì¶œë ¥)
cursor-agent -p "ì½”ë“œ ë¦¬íŒ©í† ë§"

# âœ… íŒŒì¼ ìˆ˜ì • í—ˆìš©
cursor-agent -p "ì½”ë“œ ë¦¬íŒ©í† ë§" --force
```

### **B. ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì¸í„°í˜ì´ìŠ¤ ì¬ì„¤ê³„**

**ê¸°ì¡´ ì„¤ê³„ (v1.0 - ì˜¤ë¥˜):**
```
/cursor "í”„ë¡¬í”„íŠ¸" --files file1.go file2.go
```

**ìˆ˜ì •ëœ ì„¤ê³„ (v1.1 - ì˜¬ë°”ë¦„):**
```
/cursor "ìì—°ì–´ í”„ë¡¬í”„íŠ¸ì— íŒŒì¼ëª… í¬í•¨"

ì˜ˆì‹œ:
/cursor "main.goì˜ ë²„ê·¸ë¥¼ ìˆ˜ì •í•´ì¤˜"
/cursor "handlers.goë¥¼ ë¦¬íŒ©í† ë§í•˜ê³  router.goì— ìƒˆ ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€í•´ì¤˜"
/cursor "í”„ë¡œì íŠ¸ ì „ì²´ë¥¼ ë¶„ì„í•˜ê³  ë³´ì•ˆ ì·¨ì•½ì ì„ ì°¾ì•„ì¤˜"
```

**ì•„í‚¤í…ì²˜ ì¥ì :**
1. **ë‹¨ìˆœì„±**: íŒŒì¼ ê²½ë¡œ íŒŒì‹± ë¡œì§ ë¶ˆí•„ìš”
2. **ìœ ì—°ì„±**: AIê°€ ë¬¸ë§¥ì„ ì´í•´í•˜ì—¬ ê´€ë ¨ íŒŒì¼ ìë™ íƒìƒ‰
3. **ìì—°ìŠ¤ëŸ¬ì›€**: ì‚¬ìš©ìê°€ í‰ì†Œì²˜ëŸ¼ ìì—°ì–´ë¡œ ìš”ì²­ ê°€ëŠ¥

### **C. ëª…ë ¹ì–´ ì‹¤í–‰ íŒŒë¼ë¯¸í„° ì¬ì •ì˜**

```go
// v1.0 (ì˜¤ë¥˜) - --files í”Œë˜ê·¸ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠìŒ
args := []string{
    "-p", prompt,
    "--output-format", "text",
    "--files", file1, file2,  // âŒ ì§€ì›í•˜ì§€ ì•ŠëŠ” í”Œë˜ê·¸
}

// v1.1 (ì˜¬ë°”ë¦„) - ìì—°ì–´ í”„ë¡¬í”„íŠ¸ + í•„ìˆ˜ í”Œë˜ê·¸
args := []string{
    "-p", prompt,              // íŒŒì¼ëª…ì´ í¬í•¨ëœ ìì—°ì–´ í”„ë¡¬í”„íŠ¸
    "--force",                 // íŒŒì¼ ìˆ˜ì • í—ˆìš© (í•„ìˆ˜!)
    "--output-format", "text", // ì¶œë ¥ í˜•ì‹
}
```

**ì‹¤í–‰ ì˜ˆì‹œ:**

```bash
# ì‚¬ìš©ì ì…ë ¥: /cursor "main.goì˜ ì—ëŸ¬ í•¸ë“¤ë§ì„ ê°œì„ í•´ì¤˜"
# ì‹¤ì œ ì‹¤í–‰:
cursor-agent -p "main.goì˜ ì—ëŸ¬ í•¸ë“¤ë§ì„ ê°œì„ í•´ì¤˜" --force --output-format text
```

## **III. í™˜ê²½ ì„¤ì • ë° ë¹„ë°€í‚¤ ê´€ë¦¬ (Viper)**

### **A. ì„¤ê³„ ì›ì¹™: ì„¤ì •ì˜ ì™¸ë¶€í™” (Externalized Configuration)**

ìš´ì˜-ìˆ˜ì¤€ì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ë¹„ë°€í‚¤(ì˜ˆ: `SLACK_SIGNING_SECRET`), API í‚¤, ë˜ëŠ” ë°°í¬ í™˜ê²½ì— ë”°ë¼ ë‹¬ë¼ì§€ëŠ” ì„¤ì •(ì˜ˆ: `projectBasePath`)ì„ ì†ŒìŠ¤ ì½”ë“œ ë‚´ì— í•˜ë“œì½”ë”©í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤. ì´ëŠ” ì‹¬ê°í•œ ë³´ì•ˆ ì·¨ì•½ì ì´ë©°, ì„¤ì •ì„ ë³€ê²½í•  ë•Œë§ˆë‹¤ ì½”ë“œë¥¼ ë‹¤ì‹œ ì»´íŒŒì¼í•˜ê³  ë°°í¬í•´ì•¼ í•˜ëŠ” ê²½ì§ì„±ì„ ì´ˆë˜í•©ë‹ˆë‹¤.

ë³¸ ì‹œìŠ¤í…œì€ 12-Factor App ì›ì¹™ì„ ì¤€ìˆ˜í•˜ê¸° ìœ„í•´ Go ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ìœ„í•œ ì™„ë²½í•œ ì„¤ì • ì†”ë£¨ì…˜ì¸ **Viper**ë¥¼ ì±„íƒí•©ë‹ˆë‹¤. ViperëŠ” ë‹¤ìŒ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì„¤ì •ì„ ê³„ì¸µì ìœ¼ë¡œ ë³‘í•©(Merge)í•˜ì—¬ ìœ ì—°ì„±ê³¼ ë³´ì•ˆì„ ë™ì‹œì— í™•ë³´í•©ë‹ˆë‹¤:

1. ëª…ì‹œì ì¸ Set í˜¸ì¶œ
2. í™˜ê²½ ë³€ìˆ˜ (Environment Variables)
3. ì„¤ì • íŒŒì¼ (ì˜ˆ: config.yaml)
4. ê¸°ë³¸ê°’ (Defaults)

### **B. config/config.go ëª¨ë“ˆ ì˜ì‚¬ì½”ë“œ**

ëª¨ë“  ì„¤ì •ì€ ë‹¨ì¼ `Config` êµ¬ì¡°ì²´ë¥¼ í†µí•´ íƒ€ì…-ì„¸ì´í”„(Type-safe)í•˜ê²Œ ê´€ë¦¬ë©ë‹ˆë‹¤. ViperëŠ” ì„¤ì • íŒŒì¼ê³¼ í™˜ê²½ ë³€ìˆ˜ë¥¼ ì´ êµ¬ì¡°ì²´ë¡œ ìë™ìœ¼ë¡œ Unmarshal í•©ë‹ˆë‹¤.

```go
// package config
//
// ì´ íŒŒì¼ì€ Viperë¥¼ ì‚¬ìš©í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì • ë¡œë“œ ë° ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•©ë‹ˆë‹¤.

import (
    "log"
    "strings"
    "github.com/spf13/viper"
)

// ConfigëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ëª¨ë“  ì„¤ì •ì„ ê³„ì¸µì ìœ¼ë¡œ ì •ì˜í•©ë‹ˆë‹¤.
// `mapstructure` íƒœê·¸ëŠ” Viperê°€ Unmarshalí•  ë•Œ ì‚¬ìš©í•˜ëŠ” í‚¤ì…ë‹ˆë‹¤.
type Config struct {
    Server   ServerConfig   `mapstructure:"server"`
    Slack    SlackConfig    `mapstructure:"slack"`
    Cursor   CursorConfig   `mapstructure:"cursor"`
    Security SecurityConfig `mapstructure:"security"`
    Worker   WorkerConfig   `mapstructure:"worker"`
}

type ServerConfig struct {
    Port string `mapstructure:"port"`
}

type SlackConfig struct {
    // (ë³´ì•ˆ) SigningSecretì€ íŒŒì¼ì— ì ˆëŒ€ ì €ì¥ë˜ì–´ì„œëŠ” ì•ˆ ë˜ë©°,
    // ì˜¤ì§ í™˜ê²½ ë³€ìˆ˜(SLACK_SIGNING_SECRET)ë¥¼ í†µí•´ì„œë§Œ ì£¼ì…ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
    SigningSecret string `mapstructure:"signing_secret"`
}

type CursorConfig struct {
    ProjectBasePath         string `mapstructure:"project_base_path"`
    ExecutionTimeoutSeconds int    `mapstructure:"execution_timeout_seconds"`
    CLIPath                 string `mapstructure:"cli_path"` // cursor-agent ë°”ì´ë„ˆë¦¬ ê²½ë¡œ
    APIKey                  string `mapstructure:"api_key"`  // Cursor API í‚¤ (ì„ íƒ)
}

type SecurityConfig struct {
    AllowedResponseDomains []string `mapstructure:"allowed_response_domains"`
}

type WorkerConfig struct {
    PoolSize  int `mapstructure:"pool_size"` // ë™ì‹œ ì‹¤í–‰ ì‘ì—…ì ìˆ˜
    QueueSize int `mapstructure:"queue_size"` // ì¸-ë©”ëª¨ë¦¬ ì‘ì—… í í¬ê¸°
}

// LoadConfigëŠ” ì„¤ì • íŒŒì¼(ì˜ˆ: config.yaml)ê³¼ í™˜ê²½ ë³€ìˆ˜ë¥¼ ì½ì–´ Config êµ¬ì¡°ì²´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
func LoadConfig() (config Config, err error) {
    // 1. íŒŒì¼ ì„¤ì • (ì„ íƒì )
    viper.AddConfigPath("./config") // ê²€ìƒ‰ ê²½ë¡œ 1
    viper.AddConfigPath(".")        // ê²€ìƒ‰ ê²½ë¡œ 2
    viper.SetConfigName("config")   // íŒŒì¼ ì´ë¦„ (í™•ì¥ì ì œì™¸)
    viper.SetConfigType("yaml")     // íŒŒì¼ íƒ€ì…

    // ì„¤ì • íŒŒì¼ì„ ì½ì–´ë“¤ì…ë‹ˆë‹¤. íŒŒì¼ì´ ì—†ì–´ë„ ì˜¤ë¥˜ê°€ ì•„ë‹™ë‹ˆë‹¤.
    // í™˜ê²½ ë³€ìˆ˜ë§Œìœ¼ë¡œë„ ë™ì‘í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
    _ = viper.ReadInConfig()

    // 2. í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (í•„ìˆ˜)
    // í™˜ê²½ ë³€ìˆ˜ë¥¼ ìë™ìœ¼ë¡œ ì½ì–´ë“¤ì…ë‹ˆë‹¤.
    viper.AutomaticEnv()
    
    // í™˜ê²½ ë³€ìˆ˜ í‚¤ì™€ êµ¬ì¡°ì²´ í•„ë“œ ë§¤í•‘ì„ ìœ„í•œ ë¦¬í”Œë ˆì´ì„œ ì„¤ì •
    // ì˜ˆ: security.allowed_response_domains -> SECURITY_ALLOWED_RESPONSE_DOMAINS
    viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

    // 3. (ì¤‘ìš”) í™˜ê²½ ë³€ìˆ˜ë¥¼ Viper í‚¤ì— ëª…ì‹œì ìœ¼ë¡œ ë°”ì¸ë”©
    viper.BindEnv("slack.signing_secret", "SLACK_SIGNING_SECRET")
    viper.BindEnv("cursor.project_base_path", "CURSOR_PROJECT_BASE_PATH")
    viper.BindEnv("cursor.cli_path", "CURSOR_CLI_PATH")
    viper.BindEnv("cursor.api_key", "CURSOR_API_KEY")

    // 4. ê¸°ë³¸ê°’ ì„¤ì •
    viper.SetDefault("server.port", "8080")
    viper.SetDefault("cursor.execution_timeout_seconds", 120) // 2ë¶„ íƒ€ì„ì•„ì›ƒ
    viper.SetDefault("cursor.cli_path", "cursor-agent")       // PATHì—ì„œ ê²€ìƒ‰
    viper.SetDefault("worker.pool_size", 5)                   // ë™ì‹œ ì‹¤í–‰ 5ê°œ
    viper.SetDefault("worker.queue_size", 100)
    viper.SetDefault("security.allowed_response_domains", []string{"hooks.slack.com"})

    // 5. Viper ì„¤ì •ì„ Config êµ¬ì¡°ì²´ë¡œ Unmarshal
    err = viper.Unmarshal(&config)
    if err != nil {
        return Config{}, err
    }

    // 6. (ë³´ì•ˆ) í•„ìˆ˜ ê°’ ê²€ì¦
    if config.Slack.SigningSecret == "" {
        log.Fatalf("FATAL: SLACK_SIGNING_SECRET í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„œë²„ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    }
    if config.Cursor.ProjectBasePath == "" {
        log.Fatalf("FATAL: CURSOR_PROJECT_BASE_PATH í™˜ê²½ ë³€ìˆ˜ê°€ í•„ìˆ˜ì…ë‹ˆë‹¤. cursor-agentê°€ ì‘ì—…í•  í”„ë¡œì íŠ¸ ê²½ë¡œë¥¼ ì§€ì •í•˜ì„¸ìš”.")
    }

    return config, nil
}
```

### **C. í‘œ 1: í•„ìˆ˜ ì„¤ì • íŒŒë¼ë¯¸í„° (v1.1 ì—…ë°ì´íŠ¸)**

| ì„¤ì • í‚¤ (Key) | í™˜ê²½ ë³€ìˆ˜ (Env Var) | íƒ€ì… | ì„¤ëª… | í•„ìˆ˜ |
|:-------------|:-------------------|:-----|:-----|:-----|
| server.port | SERVER_PORT | string | Gin ì„œë²„ê°€ ìˆ˜ì‹  ëŒ€ê¸°í•  í¬íŠ¸ | ì•„ë‹ˆì˜¤ (ê¸°ë³¸ê°’: 8080) |
| slack.signing_secret | SLACK_SIGNING_SECRET | string | Slack ì•±ì˜ Signing Secret. **ì ˆëŒ€ íŒŒì¼ì— ì €ì¥ ê¸ˆì§€.** | **ì˜ˆ** |
| cursor.project_base_path | CURSOR_PROJECT_BASE_PATH | string | cursor-agentê°€ ì‹¤í–‰ë  í”„ë¡œì íŠ¸ì˜ ì ˆëŒ€ ê²½ë¡œ. (ë³´ì•ˆìƒ í•„ìˆ˜) | **ì˜ˆ** |
| cursor.cli_path | CURSOR_CLI_PATH | string | cursor-agent ë°”ì´ë„ˆë¦¬ ê²½ë¡œ | ì•„ë‹ˆì˜¤ (ê¸°ë³¸ê°’: cursor-agent) |
| cursor.api_key | CURSOR_API_KEY | string | Cursor API í‚¤ (ì¸ì¦ìš©, ì„ íƒì‚¬í•­) | ì•„ë‹ˆì˜¤ |
| cursor.execution_timeout_seconds | CURSOR_EXECUTION_TIMEOUT_SECONDS | int | cursor-agent ëª…ë ¹ì˜ ìµœëŒ€ ì‹¤í–‰ ì‹œê°„(ì´ˆ) | ì•„ë‹ˆì˜¤ (ê¸°ë³¸ê°’: 120) |
| worker.pool_size | WORKER_POOL_SIZE | int | cursor-agentë¥¼ ë™ì‹œì— ì‹¤í–‰í•  ìµœëŒ€ ì‘ì—…ì ìˆ˜ | ì•„ë‹ˆì˜¤ (ê¸°ë³¸ê°’: 5) |
| worker.queue_size | WORKER_QUEUE_SIZE | int | ì¸-ë©”ëª¨ë¦¬ ì‘ì—… íì˜ ìµœëŒ€ ë²„í¼ í¬ê¸° | ì•„ë‹ˆì˜¤ (ê¸°ë³¸ê°’: 100) |
| security.allowed_response_domains | SECURITY_ALLOWED_RESPONSE_DOMAINS | []string | (SSRF ë°©ì–´) ì§€ì—° ì‘ë‹µì„ ì „ì†¡í•  Slack ë„ë©”ì¸ (ì‰¼í‘œë¡œ êµ¬ë¶„) | ì•„ë‹ˆì˜¤ (ê¸°ë³¸ê°’: hooks.slack.com) |

**v1.1 ë³€ê²½ì‚¬í•­:**
- âŒ ì œê±°: `--files` ê´€ë ¨ íŒŒì‹± ë¡œì§ (ë¯¸ì§€ì› ê¸°ëŠ¥)
- âœ… ì¶”ê°€: `cursor.cli_path` ì„¤ì • (cursor-agent ê²½ë¡œ ëª…ì‹œ)
- âœ… ì¶”ê°€: `cursor.api_key` ì„¤ì • (ì¸ì¦ ì˜µì…˜)
- âš ï¸ ê°•í™”: `cursor.project_base_path` í•„ìˆ˜í™” (ë³´ì•ˆìƒ ì¤‘ìš”)

## **IV. í•µì‹¬ ì„œë¹„ìŠ¤: ì‘ì—… ë””ìŠ¤íŒ¨ì²˜ ë° ë™ì‹œì„± ì œì–´**

ì´ ëª¨ë“ˆì€ `os/exec` ë¦¬ì†ŒìŠ¤ ê³ ê°ˆì„ ë°©ì§€í•˜ëŠ” ì‹œìŠ¤í…œì˜ í•µì‹¬ì…ë‹ˆë‹¤. HTTP ìš”ì²­ê³¼ ì‹¤ì œ ì‘ì—… ì‹¤í–‰ì„ ë¶„ë¦¬í•©ë‹ˆë‹¤.

### **A. internal/worker/job.go (ì‘ì—… ì •ì˜)**

`Job` êµ¬ì¡°ì²´ëŠ” Gin í•¸ë“¤ëŸ¬ì—ì„œ ì›Œì»¤(Worker)ë¡œ ì „ë‹¬ë˜ì–´ì•¼ í•˜ëŠ” ëª¨ë“  ì •ë³´ë¥¼ ìº¡ìŠí™”í•©ë‹ˆë‹¤.

```go
// package worker

import (
    "time"
    "github.com/your-org/cursor-slack-server/internal/server" // í•¸ë“¤ëŸ¬ì˜ í˜ì´ë¡œë“œ íƒ€ì…
)

// Jobì€ cursor-agent ì‹¤í–‰ ì‘ì—…ì„ ì •ì˜í•©ë‹ˆë‹¤.
type Job struct {
    ID          string                    // ë¡œê¹… ë° ì¶”ì ì„ ìœ„í•œ ê³ ìœ  ID (ì˜ˆ: UUID)
    Payload     server.SlackCommandPayload // Slackì—ì„œ ë°›ì€ ì›ë³¸ í˜ì´ë¡œë“œ
    ReceivedAt  time.Time                 // ìš”ì²­ ìˆ˜ì‹  ì‹œê°„ (í ëŒ€ê¸° ì‹œê°„ ì¸¡ì •ìš©)
}
```

### **B. internal/worker/dispatcher.go (ë””ìŠ¤íŒ¨ì²˜)**

DispatcherëŠ” ëª¨ë“  Workerë¥¼ ì‹œì‘í•˜ê³ , ì™¸ë¶€(í•¸ë“¤ëŸ¬)ë¡œë¶€í„° `JobQueue`ë¥¼ í†µí•´ ì‘ì—…ì„ ë°›ì•„ ìœ íœ´ Workerì—ê²Œ ë¶„ë°°í•©ë‹ˆë‹¤.

```go
// package worker

import (
    "log"
    "sync"
)

// DispatcherëŠ” ì‘ì—…ì í’€ê³¼ ì‘ì—… íë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
type Dispatcher struct {
    WorkerPool  chan chan Job // ì‘ì—…ìë“¤ì˜ ì‘ì—… ì±„ë„ì„ ë“±ë¡í•˜ëŠ” í’€
    JobQueue    chan Job      // ì™¸ë¶€(í•¸ë“¤ëŸ¬)ì—ì„œ ì‘ì—…ì„ ë°›ëŠ” ê³µìš© í
    maxWorkers  int           // ì‘ì—…ì í’€ì˜ í¬ê¸°
    workers     []*Worker     // ì‹¤í–‰ ì¤‘ì¸ ì‘ì—…ì ì¸ìŠ¤í„´ìŠ¤ (ê´€ë¦¬ìš©)
    wg          *sync.WaitGroup
    quit        chan struct{} // ë””ìŠ¤íŒ¨ì²˜ ë° ì‘ì—…ì ì¢…ë£Œ ì‹ í˜¸
}

// NewDispatcherëŠ” ë””ìŠ¤íŒ¨ì²˜ë¥¼ ìƒì„±í•˜ê³  ì‘ì—…ì í’€ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
func NewDispatcher(jobQueue chan Job, maxWorkers int) *Dispatcher {
    workerPool := make(chan chan Job, maxWorkers)

    return &Dispatcher{
        WorkerPool:  workerPool,
        JobQueue:    jobQueue,
        maxWorkers:  maxWorkers,
        wg:          new(sync.WaitGroup),
        quit:        make(chan struct{}),
    }
}

// StartëŠ” ë””ìŠ¤íŒ¨ì²˜ ë£¨í”„ë¥¼ ì‹¤í–‰í•˜ê³  ì‘ì—…ì í’€ì„ ê°€ë™í•©ë‹ˆë‹¤.
func (d *Dispatcher) Start(executor *TaskExecutor) {
    // 1. ì„¤ì •ëœ ìˆ˜(maxWorkers)ë§Œí¼ ì‘ì—…ì(Worker)ë¥¼ ìƒì„±í•˜ê³  ì‹œì‘í•©ë‹ˆë‹¤.
    for i := 0; i < d.maxWorkers; i++ {
        d.wg.Add(1)
        worker := NewWorker(i+1, d.WorkerPool, d.wg, d.quit, executor)
        worker.Start()
        d.workers = append(d.workers, worker)
    }
    
    // 2. ë””ìŠ¤íŒ¨ì¹˜ ë£¨í”„ë¥¼ ë³„ë„ì˜ Goroutineìœ¼ë¡œ ì‹¤í–‰í•©ë‹ˆë‹¤.
    go d.dispatch()
    log.Printf("%dê°œì˜ ì‘ì—…ì(Worker)ë¡œ ë””ìŠ¤íŒ¨ì²˜ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.", d.maxWorkers)
}

// dispatchëŠ” JobQueueì—ì„œ ì‘ì—…ì„ ê°€ì ¸ì™€ WorkerPoolì˜ ìœ íœ´ ì‘ì—…ìì—ê²Œ ì „ë‹¬í•©ë‹ˆë‹¤.
func (d *Dispatcher) dispatch() {
    for {
        select {
        case job := <-d.JobQueue: // 1. ì‘ì—… íì—ì„œ ìƒˆ ì‘ì—… ìˆ˜ì‹ 
            // 2. ìœ íœ´ ì‘ì—…ìì˜ ì‘ì—… ì±„ë„ì„ WorkerPoolì—ì„œ ê°€ì ¸ì˜µë‹ˆë‹¤.
            workerJobChannel := <-d.WorkerPool
            
            // 3. í•´ë‹¹ ì‘ì—…ìì—ê²Œ ì‘ì—… ì „ë‹¬
            workerJobChannel <- job
            
        case <-d.quit:
            // 4. ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ 
            return
        }
    }
}

// Stopì€ ëª¨ë“  ì‘ì—…ìì™€ ë””ìŠ¤íŒ¨ì²˜ë¥¼ ìš°ì•„í•˜ê²Œ ì¢…ë£Œí•©ë‹ˆë‹¤.
func (d *Dispatcher) Stop() {
    log.Println("ë””ìŠ¤íŒ¨ì²˜ ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ ...")
    close(d.quit)
    d.wg.Wait()
    log.Println("ëª¨ë“  ì‘ì—…ìê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.")
}
```

### **C. internal/worker/worker.go (ì‘ì—…ì)**

WorkerëŠ” ì‹¤ì œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” í–‰ìœ„ìì…ë‹ˆë‹¤. ìì‹ ì˜ ì‘ì—… ì±„ë„(`WorkChannel`)ì„ Dispatcherì˜ `WorkerPool`ì— ë“±ë¡í•˜ì—¬ ì‘ì—… í• ë‹¹ì„ ëŒ€ê¸°í•©ë‹ˆë‹¤.

```go
// package worker

import (
    "log"
    "sync"
)

// WorkerëŠ” ì‹¤ì œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” í–‰ìœ„ìì…ë‹ˆë‹¤.
type Worker struct {
    ID          int
    WorkerPool  chan chan Job   // ë””ìŠ¤íŒ¨ì²˜ì˜ ì‘ì—…ì í’€
    WorkChannel chan Job        // ì´ ì‘ì—…ì ê°œì¸ì˜ ì‘ì—… ì±„ë„
    wg          *sync.WaitGroup
    quit        chan struct{}
    executor    *TaskExecutor   // (ì˜ì¡´ì„± ì£¼ì…) ì‹¤ì œ ì‘ì—… ì‹¤í–‰ê¸°
}

// NewWorkerëŠ” ì‘ì—…ìë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
func NewWorker(id int, pool chan chan Job, wg *sync.WaitGroup, quit chan struct{}, exec *TaskExecutor) *Worker {
    return &Worker{
        ID:          id,
        WorkerPool:  pool,
        WorkChannel: make(chan Job),
        wg:          wg,
        quit:        quit,
        executor:    exec,
    }
}

// StartëŠ” ì‘ì—…ìì˜ ë©”ì¸ ë£¨í”„ë¥¼ Goroutineìœ¼ë¡œ ì‹¤í–‰í•©ë‹ˆë‹¤.
func (w *Worker) Start() {
    go func() {
        defer w.wg.Done()
        log.Printf("ì‘ì—…ì #%d ì‹œì‘ë¨", w.ID)
        
        for {
            // 1. ì‘ì—… ì¤€ë¹„ ì™„ë£Œ. ë‚´ ì‘ì—… ì±„ë„ì„ ë””ìŠ¤íŒ¨ì²˜ì˜ WorkerPoolì— ë“±ë¡
            w.WorkerPool <- w.WorkChannel
            
            select {
            case job := <-w.WorkChannel: // 2. ë””ìŠ¤íŒ¨ì²˜ë¡œë¶€í„° ì‘ì—… ìˆ˜ì‹ 
                log.Printf("ì‘ì—…ì #%d: Job %s ì²˜ë¦¬ ì‹œì‘", w.ID, job.ID)
                
                // 3. (ì¤‘ìš”) ì‹¤ì œ ì‘ì—… ì‹¤í–‰
                w.executor.Run(job)
                
                log.Printf("ì‘ì—…ì #%d: Job %s ì²˜ë¦¬ ì™„ë£Œ", w.ID, job.ID)

            case <-w.quit: // 4. ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ 
                log.Printf("ì‘ì—…ì #%d ì¢…ë£Œ ì¤‘...", w.ID)
                return
            }
        }
    }()
}
```

## **V. API ì—”ë“œí¬ì¸íŠ¸ ë° ìš”ì²­ ì²˜ë¦¬ (Gin)**

### **A. cmd/server/main.go (ì„œë²„ ì§„ì…ì )**

`main` íŒ¨í‚¤ì§€ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ "Composition Root" ì—­í• ì„ í•©ë‹ˆë‹¤. ëª¨ë“  ì˜ì¡´ì„±ì„ ìƒì„±(ì„¤ì •, ë””ìŠ¤íŒ¨ì²˜, ì‘ì—… í) ë° ì£¼ì…í•˜ê³ , ìš°ì•„í•œ ì¢…ë£Œ(Graceful Shutdown) ë¡œì§ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.

```go
// package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/your-org/cursor-slack-server/config"
    "github.com/your-org/cursor-slack-server/internal/server"
    "github.com/your-org/cursor-slack-server/internal/worker"
)

func main() {
    // 1. ì„¤ì • ë¡œë“œ (Viper)
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: %v", err)
    }

    // 2. ì˜ì¡´ì„± ìƒì„±
    
    // 2a. ì‘ì—… í ìƒì„± (ë²„í¼ í¬ê¸°ëŠ” ì„¤ì •ì—ì„œ)
    jobQueue := make(chan worker.Job, cfg.Worker.QueueSize)
    
    // 2b. TaskExecutor (ì‹¤ì œ ì‘ì—… ì‹¤í–‰ê¸°) ìƒì„±
    taskExecutor := worker.NewTaskExecutor(
        cfg.Cursor.ProjectBasePath,
        cfg.Cursor.CLIPath,
        time.Duration(cfg.Cursor.ExecutionTimeoutSeconds)*time.Second,
        cfg.Security.AllowedResponseDomains,
    )

    // 2c. Dispatcher ìƒì„± ë° ì‹œì‘ (ì‘ì—…ì í’€ ê°€ë™)
    dispatcher := worker.NewDispatcher(jobQueue, cfg.Worker.PoolSize)
    dispatcher.Start(taskExecutor)

    // 3. Gin ë¼ìš°í„° ì„¤ì • (ì˜ì¡´ì„± ì£¼ì…)
    router := server.SetupRouter(&cfg, jobQueue)

    // 4. Gin ì„œë²„ ì„¤ì • ë° ì‹œì‘ (ë³„ë„ Goroutine)
    srv := &http.Server{
        Addr:    ":" + cfg.Server.Port,
        Handler: router,
    }

    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Gin ì„œë²„ ì‹¤í–‰ ì‹¤íŒ¨: %s\n", err)
        }
    }()

    // 5. ìš°ì•„í•œ ì¢…ë£Œ(Graceful Shutdown) ì²˜ë¦¬
    quitChan := make(chan os.Signal, 1)
    signal.Notify(quitChan, syscall.SIGINT, syscall.SIGTERM)
    
    // ì‹ í˜¸ ëŒ€ê¸° (ë¸”ë¡œí‚¹)
    <-quitChan
    log.Println("ì„œë²„ ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ ...")

    // 5a. HTTP ì„œë²„ ì¢…ë£Œ (íƒ€ì„ì•„ì›ƒ ì„¤ì •)
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("HTTP ì„œë²„ ì¢…ë£Œ ì‹¤íŒ¨:", err)
    }

    // 5b. Dispatcher ë° ëª¨ë“  Worker ì¢…ë£Œ
    dispatcher.Stop()

    log.Println("ì„œë²„ê°€ ìš°ì•„í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
}
```

### **B. internal/server/router.go (ë¼ìš°í„° ì„¤ì •)**

ë¼ìš°í„°ëŠ” ì—”ë“œí¬ì¸íŠ¸ì™€ ë¯¸ë“¤ì›¨ì–´ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.

```go
// package server

import (
    "github.com/gin-gonic/gin"
    "github.com/your-org/cursor-slack-server/config"
    "github.com/your-org/cursor-slack-server/internal/server/middleware"
    "github.com/your-org/cursor-slack-server/internal/worker"
)

// SetupRouterëŠ” Gin ë¼ìš°í„°ì™€ ë¯¸ë“¤ì›¨ì–´, í•¸ë“¤ëŸ¬ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
func SetupRouter(cfg *config.Config, jobQueue chan<- worker.Job) *gin.Engine {
    r := gin.New()
    r.Use(gin.Logger())
    r.Use(gin.Recovery())

    // API ì—”ë“œí¬ì¸íŠ¸ ê·¸ë£¹í™”
    slackApi := r.Group("/slack")
    {
        // (ë³´ì•ˆ 1) Slack ìš”ì²­ ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ ì ìš©
        authMiddleware := middleware.SlackAuthMiddleware(cfg.Slack.SigningSecret)
        slackApi.Use(authMiddleware)
        
        // í•¸ë“¤ëŸ¬ ë°”ì¸ë”©
        slackApi.POST("/cursor", HandleSlashCursor(jobQueue))
    }
    
    // (ì„ íƒì ) ìƒíƒœ í™•ì¸(Health Check) ì—”ë“œí¬ì¸íŠ¸
    r.GET("/health", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{"status": "ok"}) })

    return r
}
```

### **C. internal/server/handlers.go (í•¸ë“¤ëŸ¬) - v1.1 ìˆ˜ì •**

í•¸ë“¤ëŸ¬ì˜ ì±…ì„ì€ ì´ˆê¸° ëª…ì„¸ì™€ ë‹¬ë¦¬ ëŒ€í­ ì¶•ì†Œë˜ì—ˆìŠµë‹ˆë‹¤. `os/exec`ë¥¼ ì§ì ‘ í˜¸ì¶œí•˜ëŠ” ëŒ€ì‹ , **ì¦‰ì‹œ ì‘ë‹µ(ACK)**ê³¼ **ì‘ì—… íì— ì œì¶œ**ì´ë¼ëŠ” ë‘ ê°€ì§€ ì„ë¬´ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤.

```go
// package server

import (
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
    "github.com/your-org/cursor-slack-server/internal/server/middleware"
    "github.com/your-org/cursor-slack-server/internal/worker"
)

// SlackCommandPayloadëŠ” Slackì´ ë³´ë‚´ëŠ” í¼ ë°ì´í„°ë¥¼ ë°”ì¸ë”©í•©ë‹ˆë‹¤.
type SlackCommandPayload struct {
    Text        string `form:"text"`         // v1.1: ìì—°ì–´ í”„ë¡¬í”„íŠ¸ (íŒŒì¼ëª… í¬í•¨ ê°€ëŠ¥)
    UserName    string `form:"user_name"`
    UserID      string `form:"user_id"`
    ResponseURL string `form:"response_url"`
    TriggerID   string `form:"trigger_id"`
}

// HandleSlashCursorëŠ” /cursor ëª…ë ¹ì–´ì˜ ë©”ì¸ í•¸ë“¤ëŸ¬ì…ë‹ˆë‹¤.
func HandleSlashCursor(jobQueue chan<- worker.Job) gin.HandlerFunc {
    return func(c *gin.Context) {
        var payload SlackCommandPayload
        
        if err := c.ShouldBind(&payload); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request payload"})
            return
        }
        
        // 1. ì¦‰ì‹œ ì‘ë‹µ (ACK) - 3ì´ˆ ë£° ì¤€ìˆ˜
        c.JSON(http.StatusOK, gin.H{
            "response_type": "ephemeral",
            "text":          "â³ " + payload.UserName + "ë‹˜ì˜ ìš”ì²­ì„ ì ‘ìˆ˜í–ˆìŠµë‹ˆë‹¤. ì‘ì—…ì´ íì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.",
        })

        // 2. (ë¹„ë™ê¸°) Job ìƒì„±
        reqID, exists := c.Get(middleware.RequestIDKey)
        if !exists {
            reqID = uuid.NewString()
        }

        newJob := worker.Job{
            ID:          reqID.(string),
            Payload:     payload,
            ReceivedAt:  time.Now(),
        }

        // 3. (ë¹„ë™ê¸°) Dispatcherì˜ JobQueueë¡œ ì‘ì—… ì „ì†¡
        go func() {
            jobQueue <- newJob
        }()
    }
}
```

**v1.1 ë³€ê²½ì‚¬í•­:**
- `SlackCommandPayload.Text`ì˜ ì˜ë¯¸ ì¬ì •ì˜: íŒŒì¼ ëª©ë¡ì´ ì•„ë‹Œ **ìì—°ì–´ í”„ë¡¬í”„íŠ¸**
- íŒŒì¼ ê²½ë¡œ íŒŒì‹± ë¡œì§ ì œê±° (ë¶ˆí•„ìš”)

## **VI. ë³´ì•ˆ ê³„ì¸µ 1: Slack ìš”ì²­ ì¸ì¦ ë¯¸ë“¤ì›¨ì–´**

### **A. internal/server/middleware/slack_auth.go**

ì´ ë¯¸ë“¤ì›¨ì–´ëŠ” ì„œë²„ë¡œ ë“¤ì–´ì˜¤ëŠ” ëª¨ë“  ìš”ì²­ì´ ì‹¤ì œë¡œ Slackì—ì„œ ë³´ë‚¸ ê²ƒì¸ì§€, ê·¸ë¦¬ê³  íƒˆì·¨ëœ ì˜¤ë˜ëœ ìš”ì²­ì€ ì•„ë‹Œì§€ ê²€ì¦í•˜ëŠ” **í•„ìˆ˜ ë³´ì•ˆ ê³„ì¸µ**ì…ë‹ˆë‹¤.

* **HMAC ì„œëª… ê²€ì¦:** Slack ê°€ì´ë“œì— ë”°ë¼ `X-Slack-Signature` í—¤ë”ì™€ ìš”ì²­ ë³¸ë¬¸, Signing Secretì„ ì‚¬ìš©í•˜ì—¬ HMAC-SHA256 ì„œëª…ì„ ë¹„êµí•©ë‹ˆë‹¤.
* **ì¬ì „ì†¡ ê³µê²©(Replay Attack) ë°©ì–´:** `X-Slack-Request-Timestamp` í—¤ë”ë¥¼ ì½ì–´, í˜„ì¬ ì„œë²„ ì‹œê°„ê³¼ 5ë¶„ ì´ìƒ ì°¨ì´ ë‚˜ëŠ” ì˜¤ë˜ëœ ìš”ì²­ì„ ê±°ë¶€í•©ë‹ˆë‹¤.
* **ì´ì¤‘ ë³¸ë¬¸ ì½ê¸°(Double Body Read) ë¬¸ì œ í•´ê²°:** `ioutil.ReadAll`ë¡œ ë³¸ë¬¸ì„ ì½ê³ , `ioutil.NopCloser(bytes.NewBuffer(bodyBytes))`ë¡œ ì¦‰ì‹œ ë³µì›í•©ë‹ˆë‹¤.

```go
// package middleware

import (
    "bytes"
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "io"
    "log"
    "net/http"
    "strconv"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
)

const RequestIDKey = "requestID"
const maxTimestampAge = 5 * time.Minute

// SlackAuthMiddlewareëŠ” Slack ìš”ì²­ì˜ ì„œëª…ê³¼ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
func SlackAuthMiddleware(signingSecret string) gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Set(RequestIDKey, uuid.NewString())

        // 1. ìš”ì²­ ë³¸ë¬¸ ì½ê¸° (ì´ì¤‘ ì½ê¸° ë¬¸ì œ í•´ê²°)
        bodyBytes, err := io.ReadAll(c.Request.Body)
        if err != nil {
            log.Printf("[%s] Failed to read body: %v", c.GetString(RequestIDKey), err)
            c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "Failed to read body"})
            return
        }
        c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

        // 2. íƒ€ì„ìŠ¤íƒ¬í”„ ê²€ì¦ (Replay Attack ë°©ì–´)
        timestampStr := c.GetHeader("X-Slack-Request-Timestamp")
        timestampInt, err := strconv.ParseInt(timestampStr, 10, 64)
        if err != nil {
            c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "Invalid timestamp"})
            return
        }
        timestamp := time.Unix(timestampInt, 0)
        
        if time.Since(timestamp) > maxTimestampAge {
            log.Printf("[%s] Timestamp too old (Replay Attack?): %s", c.GetString(RequestIDKey), timestampStr)
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Timestamp too old"})
            return
        }

        // 3. HMAC ì„œëª… ê²€ì¦
        slackSignature := c.GetHeader("X-Slack-Signature")
        if slackSignature == "" {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Signature missing"})
            return
        }
        
        baseString := fmt.Sprintf("v0:%s:%s", timestampStr, string(bodyBytes))
        h := hmac.New(sha256.New, []byte(signingSecret))
        h.Write([]byte(baseString))
        expectedSignature := "v0=" + hex.EncodeToString(h.Sum(nil))

        if !hmac.Equal([]byte(slackSignature), []byte(expectedSignature)) {
            log.Printf("[%s] Signature mismatch", c.GetString(RequestIDKey))
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Signature mismatch"})
            return
        }

        // 4. ëª¨ë“  ê²€ì¦ í†µê³¼
        c.Next()
    }
}
```

## **VII. ë³´ì•ˆ ê³„ì¸µ 2: ë¹„ë™ê¸° ì‘ì—… íŒŒì´í”„ë¼ì¸ (Task Executor) - v1.1 ìˆ˜ì •**

TaskExecutorëŠ” Workerë¡œë¶€í„° Jobì„ ë°›ì•„, ì‹¤ì œ cursor-agentë¥¼ ì‹¤í–‰í•˜ëŠ” ëª¨ë“  ë¡œì§ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.

### **A. internal/worker/task_executor.go (ì‘ì—… ì‹¤í–‰ê¸°) - v1.1**

```go
// package worker

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "net/url"
    "os/exec"
    "strings"
    "syscall"
    "time"
)

// TaskExecutorëŠ” ì‹¤ì œ cursor-agent ì‘ì—…ì„ ì‹¤í–‰í•˜ê³  ëª¨ë“  ë³´ì•ˆ ê²€ì¦ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
type TaskExecutor struct {
    projectBasePath         string        // (ë³´ì•ˆ) ì‘ì—…ì´ ì‹¤í–‰ë  ë£¨íŠ¸ ë””ë ‰í† ë¦¬
    cliPath                 string        // cursor-agent ë°”ì´ë„ˆë¦¬ ê²½ë¡œ
    executionTimeout        time.Duration // (ë³´ì•ˆ) ìµœëŒ€ ì‹¤í–‰ ì‹œê°„
    allowedResponseDomains  []string      // (SSRF ë°©ì–´) í—ˆìš© ë„ë©”ì¸
}

// NewTaskExecutorëŠ” TaskExecutorì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
func NewTaskExecutor(basePath string, cliPath string, timeout time.Duration, allowedDomains []string) *TaskExecutor {
    return &TaskExecutor{
        projectBasePath:        basePath,
        cliPath:                cliPath,
        executionTimeout:       timeout,
        allowedResponseDomains: allowedDomains,
    }
}

// Runì€ Jobì„ ë°›ì•„ (1)ê²€ì¦ -> (2)ì‹¤í–‰ -> (3)ì‘ë‹µì˜ ì „ì²´ íŒŒì´í”„ë¼ì¸ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
func (te *TaskExecutor) Run(job Job) {
    payload := job.Payload
    responseURL := payload.ResponseURL
    jobID := job.ID

    // 1. í”„ë¡¬í”„íŠ¸ ì¶”ì¶œ (v1.1: ë‹¨ìˆœí™”)
    prompt := strings.TrimSpace(payload.Text)
    
    if prompt == "" {
        errMsg := "âŒ í”„ë¡¬í”„íŠ¸ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤. ì‚¬ìš©ë²•: /cursor \"ìì—°ì–´ í”„ë¡¬í”„íŠ¸\""
        log.Printf("[%s] %s", jobID, errMsg)
        te.sendDelayedResponse(responseURL, errMsg)
        return
    }
    
    // 2. ëª…ë ¹ì–´ ì‹¤í–‰ (Timeout ë° Process Group)
    log.Printf("[%s] ì‘ì—…ì ì‹¤í–‰ ì‹œì‘: prompt='%s'", jobID, prompt)
    output, err := te.executeCursorCommand(jobID, prompt)
    
    // 3. ê²°ê³¼ í¬ë§·íŒ…
    resultMessage := string(output)
    if err != nil {
        log.Printf("[%s] ì‘ì—…ì ì‹¤í–‰ ì˜¤ë¥˜: %v, output: %s", jobID, err, resultMessage)
        resultMessage = fmt.Sprintf("âŒ Cursor AI ì‹¤í–‰ ì¤‘ ì—ëŸ¬ ë°œìƒ: %v\n\n%s", err, resultMessage)
    } else {
        log.Printf("[%s] ì‘ì—…ì ì‹¤í–‰ ì™„ë£Œ.", jobID)
        resultMessage = fmt.Sprintf("âœ… Cursor AI ì‘ì—… ì™„ë£Œ:\n\n%s", resultMessage)
    }

    // 4. ê²°ê³¼ ì „ì†¡ (SSRF ë°©ì–´)
    te.sendDelayedResponse(responseURL, "```\n"+resultMessage+"\n```")
}
```

### **B. cursor-agent ì•ˆì „í•œ ì‹¤í–‰ (v1.1 í•µì‹¬ ìˆ˜ì •)**

```go
// executeCursorCommandëŠ” context.WithTimeoutê³¼ process group killì„ ì‚¬ìš©í•˜ì—¬
// cursor-agentë¥¼ ì•ˆì „í•˜ê²Œ ì‹¤í–‰í•©ë‹ˆë‹¤.
func (te *TaskExecutor) executeCursorCommand(jobID string, prompt string) ([]byte, error) {
    // 1. íƒ€ì„ì•„ì›ƒ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
    ctx, cancel := context.WithTimeout(context.Background(), te.executionTimeout)
    defer cancel()

    // 2. ëª…ë ¹ì–´ ì¸ì ìƒì„± (v1.1: --force í•„ìˆ˜, --files ì œê±°)
    args := []string{
        "-p", prompt,              // ìì—°ì–´ í”„ë¡¬í”„íŠ¸ (íŒŒì¼ëª… í¬í•¨ ê°€ëŠ¥)
        "--force",                 // íŒŒì¼ ìˆ˜ì • í—ˆìš© (í•„ìˆ˜!)
        "--output-format", "text", // í…ìŠ¤íŠ¸ ì¶œë ¥
    }

    cmd := exec.CommandContext(ctx, te.cliPath, args...)
    
    // 3. (ë³´ì•ˆ) ì‘ì—… ë””ë ‰í† ë¦¬ ê²©ë¦¬
    cmd.Dir = te.projectBasePath

    // 4. (ë³´ì•ˆ í•µì‹¬) ìì‹ í”„ë¡œì„¸ìŠ¤ê¹Œì§€ í•¨ê»˜ ì¢…ë£Œí•˜ê¸° ìœ„í•´ Process Group ì„¤ì •
    cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}

    log.Printf("[%s] Executing: %s %s (in %s)", jobID, te.cliPath, strings.Join(args, " "), cmd.Dir)

    // 5. ì‹¤í–‰ ë° ê²°ê³¼ ìˆ˜ì§‘ (stdout + stderr)
    var outb, errb bytes.Buffer
    cmd.Stdout = &outb
    cmd.Stderr = &errb
    
    err := cmd.Start()
    if err != nil {
        return nil, fmt.Errorf("ëª…ë ¹ì–´ ì‹œì‘ ì‹¤íŒ¨: %w", err)
    }

    err = cmd.Wait()

    // 6. ì—ëŸ¬ ì²˜ë¦¬ (íƒ€ì„ì•„ì›ƒ í™•ì¸)
    combinedOutput := append(outb.Bytes(), errb.Bytes()...)

    if ctx.Err() == context.DeadlineExceeded {
        log.Printf("[%s] ì‘ì—… ì‹œê°„ ì´ˆê³¼ (%v). í”„ë¡œì„¸ìŠ¤ ê·¸ë£¹ ê°•ì œ ì¢…ë£Œ ì‹œë„...", jobID, te.executionTimeout)
        if cmd.Process != nil {
            _ = syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)
        }
        return combinedOutput, fmt.Errorf("ëª…ë ¹ì–´ ì‹¤í–‰ ì‹œê°„ ì´ˆê³¼ (%v)", te.executionTimeout)
    }
    
    if err != nil {
        return combinedOutput, fmt.Errorf("cursor-agent ì‹¤í–‰ ì‹¤íŒ¨: %w", err)
    }

    return combinedOutput, nil
}
```

**v1.1 í•µì‹¬ ë³€ê²½ì‚¬í•­:**

1. âœ… **`--force` í”Œë˜ê·¸ ì¶”ê°€**: íŒŒì¼ ìˆ˜ì • ê¶Œí•œ ë¶€ì—¬
2. âŒ **`--files` í”Œë˜ê·¸ ì œê±°**: cursor-agentê°€ ì§€ì›í•˜ì§€ ì•ŠëŠ” ê¸°ëŠ¥
3. ğŸ“ **í”„ë¡¬í”„íŠ¸ ë‹¨ìˆœí™”**: íŒŒì¼ ê²½ë¡œ íŒŒì‹± ë¡œì§ ì™„ì „ ì œê±°
4. ğŸ”’ **ì‘ì—… ë””ë ‰í† ë¦¬ ê³ ì •**: `cmd.Dir`ë¡œ í”„ë¡œì íŠ¸ ê²½ë¡œ ì œí•œ

### **C. SSRF ë°©ì–´ ì‘ë‹µ ì „ì†¡ (ë³€ê²½ ì—†ìŒ)**

```go
// sendDelayedResponseëŠ” SSRF ê³µê²©ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ResponseURLì„ ê²€ì¦í•œ í›„ ì „ì†¡í•©ë‹ˆë‹¤.
func (te *TaskExecutor) sendDelayedResponse(responseURL string, message string) {
    // 1. (ë³´ì•ˆ í•µì‹¬) SSRF ë°©ì–´ë¥¼ ìœ„í•œ URL ê²€ì¦
    parsedURL, err := url.Parse(responseURL)
    if err != nil {
        log.Printf("SSRF ë°©ì–´: ìœ íš¨í•˜ì§€ ì•Šì€ ResponseURL: %s", responseURL)
        return
    }

    // 2. ìŠ¤í‚´(Scheme) ê²€ì¦
    if parsedURL.Scheme != "https" {
        log.Printf("SSRF ë°©ì–´: 'https'ê°€ ì•„ë‹Œ ìŠ¤í‚´ ì°¨ë‹¨: %s", parsedURL.Scheme)
        return
    }

    // 3. í—ˆìš© ëª©ë¡(Allow-list) ê¸°ë°˜ ë„ë©”ì¸ ê²€ì¦
    isAllowed := false
    for _, allowedDomain := range te.allowedResponseDomains {
        if parsedURL.Hostname() == allowedDomain || strings.HasSuffix(parsedURL.Hostname(), "."+allowedDomain) {
            isAllowed = true
            break
        }
    }

    if !isAllowed {
        log.Printf("SSRF ë°©ì–´: í—ˆìš©ë˜ì§€ ì•ŠëŠ” ë„ë©”ì¸ìœ¼ë¡œì˜ ì‘ë‹µ ì‹œë„ ì°¨ë‹¨: %s", responseURL)
        return
    }
    
    // 4. Slack ì‘ë‹µ ì „ì†¡
    payload := map[string]interface{}{
        "text":          message,
        "response_type": "in_channel",
    }
    
    jsonPayload, err := json.Marshal(payload)
    if err != nil {
        log.Printf("Error marshaling delayed response: %v", err)
        return
    }

    resp, err := http.Post(responseURL, "application/json", bytes.NewBuffer(jsonPayload))
    if err != nil {
        log.Printf("Error sending delayed response to %s: %v", responseURL, err)
        return
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        log.Printf("Slack delayed response returned non-200 status: %d", resp.StatusCode)
    }
}
```

## **VIII. ê³ ë„í™”ëœ í”„ë¡œì íŠ¸ êµ¬ì¡° ë° ì˜ì¡´ì„± (v1.1)**

### **A. ì œì•ˆí•˜ëŠ” ë””ë ‰í† ë¦¬ êµ¬ì¡° (Standard Go Project Layout)**

```
/cursor-slack-server
â”œâ”€â”€ /cmd
â”‚   â””â”€â”€ /server
â”‚       â””â”€â”€ main.go         # ì„œë²„ ì§„ì…ì , ì˜ì¡´ì„± ì£¼ì…, ìš°ì•„í•œ ì¢…ë£Œ
â”œâ”€â”€ /config
â”‚   â”œâ”€â”€ config.go           # Viper ì„¤ì • ë¡œë”, Config êµ¬ì¡°ì²´
â”‚   â””â”€â”€ config.example.yaml # Viper ì„¤ì • ì˜ˆì‹œ íŒŒì¼
â”œâ”€â”€ /internal
â”‚   â”œâ”€â”€ /server             # Gin ì„œë²„ ê´€ë ¨ ë¡œì§: HTTP ê³„ì¸µ
â”‚   â”‚   â”œâ”€â”€ handlers.go     # HandleSlashCursor, JobQueue ì£¼ì…
â”‚   â”‚   â”œâ”€â”€ router.go       # Gin ë¼ìš°í„° ì„¤ì •
â”‚   â”‚   â””â”€â”€ /middleware     # ë¯¸ë“¤ì›¨ì–´ íŒ¨í‚¤ì§€
â”‚   â”‚       â””â”€â”€ slack_auth.go # HMAC, Timestamp ê²€ì¦
â”‚   â””â”€â”€ /worker             # ë¹„ë™ê¸° ì‘ì—…ì í’€ ê´€ë ¨ ë¡œì§: ë¹„ì¦ˆë‹ˆìŠ¤ ê³„ì¸µ
â”‚       â”œâ”€â”€ dispatcher.go   # ë””ìŠ¤íŒ¨ì²˜
â”‚       â”œâ”€â”€ job.go          # Job êµ¬ì¡°ì²´ ì •ì˜
â”‚       â”œâ”€â”€ task_executor.go # ì‹¤ì œ ì‘ì—… ì‹¤í–‰ê¸° (v1.1 ìˆ˜ì •)
â”‚       â””â”€â”€ worker.go       # ì‘ì—…ì
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ README.md
â””â”€â”€ /docs
    â””â”€â”€ /technical
        â””â”€â”€ ì„¤ê³„-ìˆ˜ì •ë³¸-v1.1.md  # ë³¸ ë¬¸ì„œ
```

### **B. go.mod í•„ìˆ˜ ì˜ì¡´ì„± (v1.1)**

```go
module github.com/your-org/cursor-slack-server

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1           // ì›¹ í”„ë ˆì„ì›Œí¬
    github.com/google/uuid v1.6.0             // ë¡œê¹…ì„ ìœ„í•œ ê³ ìœ  ID ìƒì„±
    github.com/spf13/viper v1.18.2            // ì„¤ì • ê´€ë¦¬
    
    // v1.1: íŒŒì‹± ë¼ì´ë¸ŒëŸ¬ë¦¬ ì œê±° (ë¶ˆí•„ìš”)
    // github.com/google/shlex (ì œê±°ë¨)
    // github.com/spf13/pflag (ì œê±°ë¨)
)
```

**v1.1 ë³€ê²½ì‚¬í•­:**
- âŒ ì œê±°: `github.com/google/shlex` (íŒŒì¼ ê²½ë¡œ íŒŒì‹± ë¶ˆí•„ìš”)
- âŒ ì œê±°: `github.com/spf13/pflag` (í”Œë˜ê·¸ íŒŒì‹± ë¶ˆí•„ìš”)

## **IX. ìš”ì•½: ìœ„í˜‘ ëª¨ë¸ ë° ì™„í™” ì „ëµ (v1.1 ì—…ë°ì´íŠ¸)**

### **A. í‘œ 2: ìœ„í˜‘ ëª¨ë¸ ë° ê³ ë„í™”ëœ ì™„í™” ì „ëµ**

| ìœ„í˜‘ ë²¡í„° | v1.0 ì„¤ê³„ì˜ ì·¨ì•½ì  | v1.1 ì™„í™” ì „ëµ | ê´€ë ¨ ì„¹ì…˜ |
|:----------|:-------------------|:---------------|:----------|
| **ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ (DoS)** | go runCursorTaskë¡œ Goroutine ë¬´í•œ ìƒì„± | **Worker Pool + Job Queue** ì•„í‚¤í…ì²˜ ì±„íƒ | III, IV-C |
| **ë¬´í•œ ì‹¤í–‰ (í”„ë¡œì„¸ìŠ¤ í–‰)** | cursor-agentì— íƒ€ì„ì•„ì›ƒ ì—†ìŒ | `context.WithTimeout` ì‚¬ìš©í•œ `exec.CommandContext` ê°•ì œ | VII-B |
| **ì¢€ë¹„ í”„ë¡œì„¸ìŠ¤ (ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜)** | context.WithTimeoutì´ ìì‹ í”„ë¡œì„¸ìŠ¤ ë¯¸ì¢…ë£Œ | `syscall.Setpgid` + `syscall.Kill(-pid)` í”„ë¡œì„¸ìŠ¤ ê·¸ë£¹ ê°•ì œ ì¢…ë£Œ | VII-B |
| **ì˜ëª»ëœ cursor-cli ì‚¬ìš©** | `--files` í”Œë˜ê·¸ ì‚¬ìš© (ë¯¸ì§€ì›) | âœ… `--force` í”Œë˜ê·¸ ì¶”ê°€, `--files` ì œê±°, ìì—°ì–´ í”„ë¡¬í”„íŠ¸ ì‚¬ìš© | II-B, VII-B |
| **í”„ë¡œì íŠ¸ ê²½ë¡œ ë¯¸ì§€ì •** | ì„œë²„ ì‹¤í–‰ ë””ë ‰í† ë¦¬ ê¸°ë³¸ê°’ ì‚¬ìš© (ìœ„í—˜) | `CURSOR_PROJECT_BASE_PATH` í•„ìˆ˜í™”, ê²€ì¦ ê°•í™” | II-C |
| **ì„œë²„ ì¸¡ ìš”ì²­ ìœ„ì¡° (SSRF)** | response_urlì„ ê²€ì¦ ì—†ì´ http.Post ì „ì†¡ | `url.Parse` + Allow-list ë„ë©”ì¸ ê²€ì¦ (hooks.slack.com) | VII-C |
| **ì¬ì „ì†¡ ê³µê²© (Replay Attack)** | Slack ì„œëª… ê²€ì¦ë§Œ ìˆ˜í–‰ (íƒ€ì„ìŠ¤íƒ¬í”„ ë¯¸ê²€ì¦) | `X-Slack-Request-Timestamp` 5ë¶„ ë§Œë£Œ ê²€ì¦ | VI-A |
| **ì¸ì¦ ìš°íšŒ (Body Read)** | ë¯¸ë“¤ì›¨ì–´/í•¸ë“¤ëŸ¬ ì´ì¤‘ Body ì½ê¸° ë¬¸ì œ | `io.ReadAll` + `io.NopCloser` ë³µì› | VI-A |
| **ì„¤ì • í•˜ë“œì½”ë”©** | projectBasePath ë“± í•˜ë“œì½”ë”© ê°€ëŠ¥ì„± | Viperë¥¼ í†µí•œ ê³„ì¸µì  ì„¤ì • ê´€ë¦¬, í™˜ê²½ ë³€ìˆ˜ ìš°ì„  | III |

### **B. v1.0 â†’ v1.1 ì£¼ìš” ë³€ê²½ì‚¬í•­ ìš”ì•½**

| êµ¬ë¶„ | v1.0 (ì˜¤ë¥˜) | v1.1 (ìˆ˜ì •) | ì˜í–¥ë„ |
|:-----|:-----------|:-----------|:-------|
| cursor-cli íŒŒë¼ë¯¸í„° | `--files file1 file2` | `--force --output-format text` | ğŸ”´ Critical |
| ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ í˜•ì‹ | `/cursor "í”„ë¡¬í”„íŠ¸" --files ...` | `/cursor "ìì—°ì–´ í”„ë¡¬í”„íŠ¸"` | ğŸ”´ Critical |
| íŒŒì‹± ë¡œì§ | shlex + pflag ë³µì¡í•œ íŒŒì‹± | ë‹¨ìˆœ `strings.TrimSpace()` | ğŸŸ¡ High |
| í”„ë¡œì íŠ¸ ê²½ë¡œ | ì„ íƒ ì‚¬í•­ (ê¸°ë³¸ê°’: í˜„ì¬ ë””ë ‰í† ë¦¬) | **í•„ìˆ˜** í™˜ê²½ ë³€ìˆ˜ | ğŸŸ¡ High |
| ì˜ì¡´ì„± | shlex, pflag í¬í•¨ | shlex, pflag ì œê±° | ğŸŸ¢ Medium |
| ë¬¸ì„œí™” | cursor-cli ë™ì‘ ë°©ì‹ ë¯¸ë°˜ì˜ | ì‹¤ì œ ë™ì‘ ì›ë¦¬ ìƒì„¸ ì„¤ëª… | ğŸŸ¢ Medium |

### **C. í–¥í›„ í™•ì¥ì„± ê¶Œê³  (ë³€ê²½ ì—†ìŒ)**

í˜„ì¬ ì•„í‚¤í…ì²˜ëŠ” ì¸-ë©”ëª¨ë¦¬(in-memory) `chan Job`ì„ ì‘ì—… íë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ ë°©ì‹ì€ êµ¬í˜„ì´ ê°„ë‹¨í•˜ì§€ë§Œ, ì„œë²„ê°€ ì¬ì‹œì‘ë  ê²½ìš° íì— ëŒ€ê¸° ì¤‘ì´ë˜ ëª¨ë“  ì‘ì—…ì´ ìœ ì‹¤ë˜ëŠ” ë‹¨ì ì´ ìˆìŠµë‹ˆë‹¤.

ì‹œìŠ¤í…œì˜ ì¤‘ìš”ë„ê°€ ë†’ì•„ì§€ê³  ì‘ì—… ìœ ì‹¤ì„ ë°©ì§€í•´ì•¼ í•  ê²½ìš°, ë‹¤ìŒ ë‹¨ê³„ëŠ” ì´ ì¸-ë©”ëª¨ë¦¬ íë¥¼ Redisì™€ ê°™ì€ ì™¸ë¶€ ë¸Œë¡œì»¤ë¥¼ ì‚¬ìš©í•˜ëŠ” **ì˜ì†ì„± ìˆëŠ”(Persistent) ì‘ì—… í**ë¡œ êµì²´í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. Asynq ë˜ëŠ” gocraft/workì™€ ê°™ì€ Go ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë³¸ ë³´ê³ ì„œì—ì„œ ì œì•ˆëœ Dispatcherì™€ Worker ì•„í‚¤í…ì²˜ëŠ” ì´ëŸ¬í•œ ì™¸ë¶€ í ì‹œìŠ¤í…œê³¼ ì‰½ê²Œ í†µí•©ë˜ë„ë¡ ì¶”ìƒí™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

## **X. ê²°ë¡  ë° ë‹¤ìŒ ë‹¨ê³„**

### **A. v1.1 ì„¤ê³„ì˜ í•µì‹¬ ì›ì¹™**

1. **ì •í™•ì„± ìš°ì„ **: cursor-agentì˜ ì‹¤ì œ ë™ì‘ ë°©ì‹ì„ ì •í™•íˆ ë°˜ì˜
2. **ë‹¨ìˆœì„± ì¶”êµ¬**: ë¶ˆí•„ìš”í•œ ë³µì¡ì„±(íŒŒì¼ ê²½ë¡œ íŒŒì‹±) ì œê±°
3. **ë³´ì•ˆ ê°•í™”**: í”„ë¡œì íŠ¸ ê²½ë¡œ í•„ìˆ˜í™”, SSRF/Replay Attack ë°©ì–´
4. **í™•ì¥ ê°€ëŠ¥ì„±**: Worker Pool ì•„í‚¤í…ì²˜ë¡œ ë¦¬ì†ŒìŠ¤ ì œì–´

### **B. êµ¬í˜„ ìš°ì„ ìˆœìœ„ (ì  â†’ ì› â†’ êµ¬ì²´)**

**ì  ë‹¨ê³„ (MVP):**
- âœ… HMAC ì¸ì¦ + Replay Attack ë°©ì–´
- âœ… ë¹„ë™ê¸° cursor-agent ì‹¤í–‰
- ğŸ”´ **ì¦‰ì‹œ ìˆ˜ì • í•„ìš”**: `--force` í”Œë˜ê·¸ ì¶”ê°€, `--files` ì œê±°

**ì› ë‹¨ê³„ (ì•ˆì •ì„±):**
- [ ] Worker Pool + Dispatcher êµ¬í˜„
- [ ] Viper ì„¤ì • ê´€ë¦¬
- [ ] SSRF ë°©ì–´
- [ ] Process Group ê´€ë¦¬
- [ ] Graceful Shutdown

**êµ¬ì²´ ë‹¨ê³„ (ì—”í„°í”„ë¼ì´ì¦ˆ):**
- [ ] Redis ê¸°ë°˜ ì˜ì†ì„± í
- [ ] ì‘ì—… ê²°ê³¼ ì¡°íšŒ API
- [ ] ë©”íŠ¸ë¦­ ë° ëª¨ë‹ˆí„°ë§
- [ ] Rate Limiting
- [ ] cursor-cli ê¶Œí•œ ì‹œìŠ¤í…œ í†µí•©

### **C. ì¦‰ì‹œ ì ìš© ê°€ëŠ¥í•œ ì½”ë“œ ìˆ˜ì •**

ë‹¤ìŒ ëª…ë ¹ì–´ í•˜ë‚˜ë¡œ í˜„ì¬ êµ¬í˜„ì„ v1.1 ì„¤ê³„ì— ë§ê²Œ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```go
// handlers.goì˜ executeCursorCLI í•¨ìˆ˜ ìˆ˜ì •
args := []string{
    "-p", prompt,              // ìì—°ì–´ í”„ë¡¬í”„íŠ¸ (íŒŒì¼ëª… í¬í•¨)
    "--force",                 // íŒŒì¼ ìˆ˜ì • í—ˆìš© ì¶”ê°€ âœ…
    "--output-format", "text",
    // --files ê´€ë ¨ ë¡œì§ ì™„ì „ ì œê±° âŒ
}
```

---

**ë³¸ ì„¤ê³„ ë¬¸ì„œ(v1.1)ëŠ” cursor-agentì˜ ì‹¤ì œ ë™ì‘ ë°©ì‹ì„ ë°˜ì˜í•˜ì—¬, ì•ˆì •ì ì´ê³  í™•ì¥ ê°€ëŠ¥í•œ Slack-Cursor-CLI ì—°ë™ ì„œë²„ë¥¼ êµ¬ì¶•í•˜ê¸° ìœ„í•œ ì™„ì „í•œ ì•„í‚¤í…ì²˜ ê°€ì´ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.**

