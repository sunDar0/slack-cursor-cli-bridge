

# **무료 배포 아키텍처 심층 분석: 로컬 터널링부터 클라우드 네이티브 배포까지 \- Slack 브릿지 서버를 위한 완벽 가이드**

## **I. 서론: '배포'와 '테스트'의 명확한 구분**

### **1.1. 사용자 쿼리 분석: 슬랙 브릿지 서버의 기술적 요구사항**

사용자의 목표는 '슬랙 브릿지 서버' 토이 프로젝트를 위한 무료 공개 URL을 확보하는 것입니다. 슬랙 브릿지 서버는 본질적으로 외부 웹훅(Webhook) 수신자(Receiver)로 작동합니다. 슬랙의 슬래시 커맨드(Slash Command)나 이벤트 API는 사용자가 앱 설정에 구성한 'Request URL'로 HTTP POST 요청을 전송합니다.1

이러한 아키텍처는 다음과 같은 명확하고 엄격한 기술적 요구사항을 전제로 합니다:

1. **공개 액세스:** URL은 방화벽이나 NAT 뒤가 아닌, 공용 인터넷에서 액세스할 수 있어야 합니다.  
2. **안정성 (Persistence):** URL은 변경되지 않아야 합니다. URL이 변경될 때마다 슬랙 앱 설정을 수동으로 업데이트하는 것은 '배포' 상태로 볼 수 없습니다.3  
3. **프로토콜:** 슬랙은 보안을 위해 HTTPS 엔드포인트를 요구합니다.  
4. **응답 시간:** 슬랙 웹훅은 3초 이내에 $200$ OK 응답을 받아야 합니다. 3초가 초과하면 슬랙은 해당 요청을 'Timeout'으로 간주하고 실패로 처리합니다.

### **1.2. 사용자의 근본적인 오해: $ngrok$은 '배포(Deploy)'가 아닌 '테스트(Test)' 도구**

사용자는 $ngrok$을 "무료 배포" 수단으로 요청했습니다. 과거 $ngrok$의 무료 등급은 에이전트를 재시작할 때마다 URL이 변경되는 '임시(ephemeral)' URL만을 제공했습니다.4 이 모델 하에서 $ngrok$은 실시간 디버깅 및 단기 테스트에는 매우 유용하지만, URL이 지속적으로 변경되어 안정적인 '배포' 솔루션으로는 근본적으로 부적합했습니다.3

그러나 최근 $ngrok$의 정책 변경으로 인해 이 분석은 수정이 필요합니다. 최신 $ngrok$ 문서는 무료 등급 사용자에게도 **"1 ngrok static domain"** (정적 도메인 1개)을 제공한다고 명시하고 있습니다.5 일부 커뮤니티에서도 "ngrok이 최근 무료 고정 URL을 추가했다"고 언급합니다.7

이 변화는 $ngrok$을 '단순 테스트' 도구에서 '제한적인 무료 배포' 솔루션으로 격상시킵니다. 이제 $ngrok$의 치명적 한계는 'URL의 비영속성'이 아니라, (1) '로컬 머신에 대한 인프라 의존성' 및 (2) '매우 엄격한 무료 등급 리소스 제한'으로 이동합니다.5

### **1.3. 보고서의 목표 및 아키텍처 탐색 경로**

본 보고서는 단순한 $ngrok$ 사용법을 넘어, '안정적인 무료 공개 URL 확보'라는 사용자의 근본 목표를 달성하기 위한 두 가지 전문적인 아키텍처를 제시합니다.

* **전략 1: 영구 터널링 (Persistent Tunneling):** 사용자의 로컬 머신을 프로덕션 서버로 활용하는 고급 터널링 기법을 분석합니다. $ngrok$의 새로운 정적 도메인 기능을 포함하여 $Cloudflare Tunnel$, $zrok$ 등 주요 대안을 심층 비교합니다.  
* **전략 2: 클라우드 네이티브 배포 (Cloud-Native PaaS):** 로컬 머신 의존성을 완전히 제거하고, 관리형 클라우드 플랫폼(PaaS)에 애플리케이션을 직접 배포하는 '실제' 배포 방식을 제안합니다.

두 전략 모두 사용자의 기술 스택(Go 언어 기반 애플리케이션 및 $cursor-cli$와 같은 외부 바이너리 의존성 9)을 처리할 수 있는 구체적인 기술 가이드를 포함합니다.

## **II. 전략 1: 영구 터널링 아키텍처 및 무료 옵션 심층 비교**

이 전략은 사용자의 로컬 개발 머신(예: 노트북 또는 데스크톱)에서 슬랙 브릿지 서버를 직접 실행하고, 터널링 소프트웨어를 통해 이 로컬 서버를 공용 인터넷에 노출시킵니다.

### **2.1. $ngrok$: 정적 도메인을 활용한 '쉬운' 배포 솔루션**

$ngrok$의 무료 정적 도메인 기능을 활용하면 사용자의 초기 요청을 가장 빠르게 충족시킬 수 있습니다.

1. **설치 및 인증:** $ngrok$ 에이전트를 설치합니다(예: macOS의 경우 brew install ngrok 11). $ngrok$ 대시보드에서 'authtoken'을 복사하여 CLI에 등록합니다 (ngrok config add-authtoken $YOUR\_TOKEN 11). 인증은 무료 정적 도메인 기능을 사용하기 위한 필수 단계입니다.  
2. **로컬 서버 실행:** 사용자의 Go 기반 슬랙 브릿지 서버를 로컬에서 실행합니다. 예를 들어, Go Gin 서버가 $localhost:8080$에서 실행 중이라고 가정합니다.11  
3. **정적 도메인으로 터널 실행:** 기존의 임시 URL 방식(ngrok http 8080 11) 대신, $--url$ 플래그를 사용하여 대시보드에서 설정한 정적 도메인을 지정합니다.14  
   * ngrok http 8080 \--url https://\<your-chosen-subdomain\>.ngrok.dev  
4. **슬랙 연동:** 생성된 영구 URL(예: https://\<subdomain\>.ngrok.dev/slack/events)을 슬랙 앱 설정의 'Request URL' 필드에 한 번만 등록합니다.1 이제 $ngrok$ 에이전트나 로컬 서버를 재시작해도 이 URL은 변경되지 않습니다.

### **2.2. $ngrok$ 무료 등급의 '실제' 한계 분석**

정적 URL 문제가 해결되었음에도 불구하고, $ngrok$ 무료 등급은 '배포' 환경으로 사용하기에는 다음과 같은 심각한 한계가 존재합니다.

* **인프라 의존성 (가장 큰 문제):** 이 아키텍처는 사용자의 로컬 개발 머신이 24시간 365일 켜져 있고, 안정적인 인터넷 연결을 유지해야 함을 전제로 합니다. 노트북을 닫거나, 절전 모드로 전환되거나, Wi-Fi 연결이 끊기거나, $ngrok$ 에이전트 프로세스가 중단되면 슬랙 브릿지 서버는 즉시 다운됩니다.  
* **엄격한 리소스 제한:** $ngrok$ 무료 등급은 토이 프로젝트에도 부족할 수 있는 매우 엄격한 리소스 제한을 적용합니다.  
  * **대역폭:** 월 1 GB의 아웃바운드(Outgoing) 데이터 전송만 허용됩니다.5 슬랙 브릿지가 간단한 텍스트 응답만 처리한다면 충분할 수 있지만, 이미지나 파일 데이터를 프록시하는 기능을 추가하는 순간 이 한계는 즉시 소진됩니다.  
  * **요청 수:** 월 20,000건의 HTTP(S) 요청으로 제한됩니다.5 이는 시간당 약 27건, 분당 약 0.45건에 불과합니다. 몇 명의 사용자가 있는 활발한 슬랙 워크스페이스에서도 이 한계는 며칠 내에 고갈될 수 있습니다.  
  * **요청 비율:** 분당 120개 요청(HTTP Request Rate Limit)으로 속도가 제한됩니다.8 슬랙 이벤트가 특정 시점에 버스트(burst) 형태로 몰릴 경우(예: 봇이 여러 채널에 동시에 추가될 때) 속도 제한(Rate Limit)에 걸려 요청이 실패할 수 있습니다.

결론적으로 $ngrok$의 무료 정적 도메인은 '배포'를 *가능하게* 하지만, 안정성과 가용성이 사실상 없는 매우 가벼운 개인용 토이 프로젝트에만 적합합니다.

### **2.3. 대안 1: Cloudflare Tunnel (가장 강력한 터널링)**

$ngrok$의 대안 중 가장 전문적이고 강력한 솔루션은 $Cloudflare Tunnel$ (이전 $Argo Tunnel$)입니다.

* **아키텍처:** $cloudflared$라는 경량 에이전트를 로컬 머신에 설치하고, $Cloudflare$의 방대한 글로벌 엣지 네트워크(CDN)를 통해 로컬 서버에 연결합니다.18  
* **장점:**  
  * **압도적인 무료 등급:** $Cloudflare$의 기본 무료 플랜에 포함되어 있어 19, $ngrok$의 1GB 대역폭이나 20k 요청 수와 같은 엄격한 제한이 사실상 없습니다.20  
  * **엔터프라이즈급 기능:** $Cloudflare$의 강력한 무료 DDoS 보호, 웹 방화벽(WAF), 자동 HTTPS 및 SSL 인증서 관리를 모두 무료로 제공받습니다.20  
  * **성능 및 안정성:** $ngrok$의 중앙 서버를 경유하는 대신, $Cloudflare$의 엣지 네트워크를 활용하여 지연 시간(latency)이 낮고 성능이 우수합니다.18 "Production-grade" 터널로 평가받습니다.22  
* **치명적 단점 (Hurdle):**  
  * $ngrok$과 달리 $Cloudflare Tunnel$은 .ngrok.dev와 같은 무료 하위 도메인을 제공하지 않습니다. 사용자는 **반드시 자신 소유의 도메인을 구매**(연 $10\~$15 비용 발생)해야 하며, 해당 도메인의 네임서버를 $Cloudflare$로 지정해야 합니다.23 이는 "완전 무료"라는 사용자의 핵심 제약 조건을 위반합니다.  
  * $ngrok$의 임시 URL과 유사하게, $trycloudflare$라는 'Quick Tunnels' 기능이 있지만 24, 이는 URL이 영구적이지 않아 배포에는 부적합하며 동시 요청 200개 제한이 있습니다.24

### **2.4. 기타 무료 터널링 대안 (Hobbyist Options)**

$ngrok$과 $Cloudflare Tunnel$ 외에도 다양한 무료 및 오픈소스 대안이 존재합니다.25

* **$localtunnel.me$:** npm을 통해 쉽게 설치할 수 있으며 27, 요청 시 원하는 하위 도메인을 받아 영구적으로 사용할 수 있습니다.28 유료 플랜이 없는 완전 무료 서비스입니다.27 하지만 서비스의 신뢰성(reliability)이 낮다는 평가가 있으며 29, 서버가 응답하지 않는 경우가 보고됩니다.30  
* **$zrok.io$:** 오픈소스(Apache 2.0) 기반의 강력한 대안입니다.27 무료 SaaS를 제공하며, $ngrok$의 1GB/월 제한보다 훨씬 관대한 **24시간당 10GB**의 트래픽을 허용합니다.30 또한 'reserved shares'라는 기능을 통해 영구 URL을 무료로 제공합니다.31 $ngrok$의 가장 강력한 '완전 무료' 경쟁자입니다.  
* **$pinggy.io$:** 별도 프로그램 다운로드 없이 SSH를 통해 터널링을 제공하는 독특한 서비스입니다.25 하지만 무료 등급은 **60분의 시간 제한**이 있어 28 지속적인 배포 환경에는 부적합합니다.

### **2.5. 전략 1 비교 및 결론**

로컬 터널링 전략은 빠른 설정이 가능하지만, 모든 옵션이 '로컬 머신 24/7 실행'이라는 근본적인 아키텍처 약점을 공유합니다.

**표 1: 무료 터널링 솔루션 아키텍처 비교**

| 기능 | ngrok (Free) | CloudflareTunnel (Free) | zrok.io (Free SaaS) | localtunnel.me |
| :---- | :---- | :---- | :---- | :---- |
| **초기 비용** | 무료 ($\<subdomain\>.ngrok.dev$ 제공) 5 | **도메인 구매 비용** (연 $10\~$15) 23 | 무료 ($\<subdomain\>.zrok.io$ 제공) 31 | 무료 27 |
| **영구 URL** | **예 (1개 정적 도메인)** 5 | **예 (무제한 하위 도메인)** \[21, 23\] | **예 (Reserved Shares)** 31 | 예 (요청 시) 28 |
| **핵심 제한** | 1GB/월 (대역폭) 5 20,000건/월 (요청) 8 120건/분 (속도) 8 | $Cloudflare$ 무료 등급 (매우 관대함) 20 | **10GB/24시간 (대역폭 \+ 트래픽)** 30 | 제한 없음 (신뢰성 문제) \[27, 29\] |
| **인프라** | 로컬 머신 24/7 실행 | 로컬 머신 24/7 실행 | 로컬 머신 24/7 실행 | 로컬 머신 24/7 실행 |

이 분석에 따르면, 사용자가 도메인 구매 의사가 있다면 $Cloudflare Tunnel$이 기술적으로 가장 우수합니다. 완전 무료 옵션 중에서는 $zrok.io$가 $ngrok$보다 훨씬 관대한 리소스를 제공하는 강력한 대안입니다.

## **III. 전략 2: 클라우드 PaaS를 이용한 서버리스 배포 아키텍처 (권장)**

이 전략은 로컬 머신 의존성을 근본적으로 해결합니다. 사용자의 Go 소스 코드나 Docker 컨테이너를 클라우드 플랫폼에 업로드하면, 플랫폼이 컴파일, 배포, 네트워킹, 스케일링을 모두 자동 관리합니다.32 'Always-Free' 등급은 트래픽이 없을 때 비용이 0으로 수렴하며, 안정적인 하위 도메인(예: .onrender.com, .run.app)을 무료로 제공합니다.

### **3.1. 아키텍처 전환: 왜 PaaS(Platform-as-a-Service)인가?**

PaaS를 사용하면 사용자의 노트북이 꺼져 있어도 슬랙 브릿지 서버는 클라우드에서 24/7 안정적으로 실행됩니다. 이는 '테스트'가 아닌 진정한 '배포'입니다.

### **3.2. 무료 PaaS 옵션 스크리닝: '무료'의 함정 구별하기**

모든 PaaS가 동일한 '무료'를 제공하는 것은 아닙니다. 슬랙 브릿지 서버의 요구사항에 맞춰 각 서비스를 면밀히 스크리닝해야 합니다.

#### **3.2.1. 탈락 (Not Free): $Railway.app$**

* **분석:** $Railway$는 전통적인 '항상 무료' 등급을 제공하지 않습니다.33 대신 신규 사용자에게 일회성 $5의 무료 크레딧을 제공합니다.34  
* **결론:** 이 크레딧은 사용량에 따라 소진되며(월 $5\~$10 소요 예상 36), 크레딧이 소진되면 서비스는 중단됩니다.33 이는 '지속 가능한 무료 배포'가 아닌 '무료 평가판(Trial)'이므로 사용자의 요구에 부합하지 않습니다.

#### **3.2.2. 탈락 (Unreliable Free): $Fly.io$**

* **분석:** $Fly.io$는 한때 강력한 무료 등급을 제공하여 Go 커뮤니티에서 인기가 높았으나 37, 최근 가격 정책이 변경되었습니다.38  
* **핵심 증거:** $Fly.io$ 커뮤니티 포럼에는 "무료 등급이 죽었나?(Is the free tier dead?)"라는 질문과 함께, 분명히 무료 등급 리소스(예: $shared-cpu-1x$ 256MB VM 1대)를 사용 중임에도 $0.03$, $0.07$ 등 소액 과금이 발생했다는 보고가 잇따르고 있습니다.40  
* **결론:** '무료'를 원했던 사용자가 예상치 못한 과금을 당할 위험40이 존재합니다. 이 불확실성 때문에 $Fly.io$는 추천에서 제외합니다.

#### **3.2.3. 함정 (The Trap): $Render.com$**

* **장점:** 사용이 매우 쉽고, Git 리포지토리를 연결하면 Go 앱을 네이티브로 빌드 및 배포해줍니다.41 무료 .onrender.com 하위 도메인도 제공합니다.  
* **치명적 단점:** $Render$의 무료 웹 서비스는 **15분간 트래픽이 없으면 서비스가 '휴면(Spin-down)' 상태** (즉, 0으로 축소)가 됩니다.43  
* **아키텍처 부적합성 (Render의 콜드 스타트와 슬랙의 3초 타임아웃):**  
  1. **전제 1:** 슬랙 웹훅은 3초 이내에 응답을 받아야 합니다.  
  2. **전제 2:** $Render$의 무료 등급은 15분 미사용 시 휴면 상태가 됩니다.43  
  3. **문제:** 휴면 상태의 서비스가 첫 요청을 받아 다시 '깨어나는(Cold Start)' 데는 15초에서 30초 이상 소요될 수 있습니다.  
  4. **결론:** 사용자가 15분 이상 휴식 후 슬랙 커맨드를 입력하면, $Render$의 콜드 스타트 시간(예: 20초)이 슬랙의 타임아웃(3초)을 *항상* 초과하게 됩니다. 이는 슬랙 브릿지 서버가 *작동 불능*임을 의미합니다.  
* **판정:** $Render.com$ 무료 등급은 간헐적으로 방문하는 개인 블로그나 포트폴리오 웹사이트 호스팅에는 적합하나, 즉각적인 응답이 필요한 *웹훅 수신기*에는 아키텍처적으로 부적합합니다.

#### **3.2.4. 최종 후보 (권장): $Google Cloud Run$**

* **장점:** $Google Cloud Run$은 업계에서 가장 관대한 '영구 무료 등급(Always-Free Tier)'을 제공합니다.44 이 무료 등급은 매월 갱신되며, 월 240,000 vCPU-초, 450,000 GiB-초의 리소스를 포함합니다.46 이는 개인용 토이 프로젝트에 차고 넘치는 용량입니다.  
* **핵심 기능:** $Render$와 마찬가지로 트래픽이 없으면 0으로 축소(Scale-to-Zero)되어 비용이 발생하지 않습니다. 하지만 $Cloud Run$은 *초고속 콜드 스타트*(일반적으로 1\~3초 이내)에 최적화된 서버리스 플랫폼입니다.  
* **결론:** $Google Cloud Run$은 슬랙의 3초 타임아웃 요구사항을 만족시킬 수 있는 빠른 콜드 스타트 성능, '무료' 요구사항(관대한 영구 무료 등급 46), '안정적인 URL' 요구사항(영구적인 .run.app 도메인 제공)을 모두 충족하는 *유일한* PaaS 솔루션입니다.  
* **단점:** $Render$와 달리 네이티브 Go 빌드를 지원하지 않고, **Docker 컨테이너 배포가 필수**입니다.37

## **IV. 실전 배포 가이드 1: Go \+ $cursor-cli$ 프로젝트의 컨테이너화 (Cloud Run 준비)**

$Google Cloud Run$ 배포를 위해서는 사용자의 Go 애플리케이션과 그 의존성($cursor-cli$)을 단일 Docker 이미지로 패키징해야 합니다.

### **4.1. 아키텍처 과제: Go 바이너리와 외부 바이너리($cursor-cli$)의 결합**

사용자의 애플리케이션은 (1) 직접 컴파일한 Go 바이너리와 (2) $cursor-cli$라는 외부 바이너리라는 두 가지 실행 파일 의존성을 가집니다.9 $cursor-cli$는 일반적으로 curl https://cursor.com/install \-fsS | bash 명령어를 통해 설치됩니다.10 이 두 가지를 모두 포함하는 경량화된 이미지가 필요합니다.

### **4.2. 솔루션: 멀티 스테이지 Dockerfile을 통한 최적화**

멀티 스테이지 빌드($Dockerfile$ 내에 여러 FROM 구문 사용)는 빌드 환경과 최종 런타임 환경을 분리하여, 최종 이미지 크기를 최소화하고54 보안을 강화하는 Docker의 모범 사례입니다.49

다음은 Go 바이너리와 $cursor-cli$ 바이너리를 결합하는 최적화된 Dockerfile 예시입니다.

Dockerfile

\# \--- Stage 1: Go Builder \---  
\# Go 애플리케이션을 빌드하기 위한 스테이지입니다.  
\# 공식 Go 이미지를 사용하며, 경량화를 위해 alpine 버전을 선택합니다.\[52, 53\]  
FROM golang:1.21\-alpine AS builder

\# 작업 디렉토리를 설정합니다.  
WORKDIR /app

\# Go 모듈 의존성을 먼저 복사하고 다운로드합니다.  
\# 이 단계는 소스 코드가 변경되지 않으면 Docker 레이어 캐싱을 활용하여 빌드 속도를 높입니다.  
COPY go.mod go.sum./  
RUN go mod download

\# 나머지 소스 코드 전체를 복사합니다.  
COPY..

\# CGO\_ENABLED=0을 설정하여 정적 바이너리를 빌드합니다.  
\# 이는 최종 이미지가 'alpine'이나 'scratch' 같은 최소 환경에서 C 라이브러리 의존성 없이  
\# 실행될 수 있도록 보장합니다.  
\# /app/slack-bridge-server 경로에 바이너리를 생성합니다.  
RUN CGO\_ENABLED=0 GOOS=linux go build \-o /app/slack-bridge-server./cmd/main.go

\# \--- Stage 2: Cursor-CLI Fetcher \---  
\# 외부 바이너리(cursor-cli)를 다운로드하기 위한 별도 스테이지입니다.  
\# curl | bash \[10\] 스크립트 실행은 Docker 빌드 시 비명시적이며 불안정할 수 있습니다.  
\# 대신, 공식 다운로드 페이지\[55\]에 명시된 AppImage 바이너리를 직접 다운로드합니다.  
FROM alpine:latest AS cursor-fetcher

WORKDIR /app

\# AppImage를 다운로드하기 위해 curl을 설치합니다.\[56\]  
RUN apk \--no-cache add curl

\# \[55\](Linux x64 AppImage)에서 URL을 유추하여 다운로드합니다.  
\# 이 방식이 \[10\]의 스크립트 실행보다 훨씬 안정적이고 명시적입니다.  
\# 공식 URL을 사용하거나, 확인된 직접 링크를 사용해야 합니다.  
\# \[55\]  
\# 여기서는 의 설치 스크립트를 사용하는 방식을 따르되,  
\# AppImage \[55\] 또는 스크립트가 설치하는 바이너리\[47\]를 복사합니다.  
\# 여기서는 \[10\]의 스크립트를 실행하여 바이너리를 확보합니다.  
RUN curl https://cursor.com/install \-fsS | bash  
\# 스크립트는 바이너리를 $HOME/.local/bin/cursor-agent 에 설치합니다.\[47\]

\# \--- Stage 3: Final Image \---  
\# 런타임에 필요한 최소한의 alpine 이미지를 기반으로 최종 이미지를 생성합니다.\[50\]  
FROM alpine:latest

WORKDIR /app

\# Stage 1 (builder)에서 컴파일된 Go 바이너리를 복사합니다.\[49\]  
COPY \--from=builder /app/slack-bridge-server.

\# Stage 2 (cursor-fetcher)에서 설치된 cursor-agent 바이너리를 복사합니다.\[49\]  
\# \[47\]에 따라 경로는 /root/.local/bin/cursor-agent 입니다 (alpine의 $HOME).  
COPY \--from=cursor-fetcher /root/.local/bin/cursor-agent.

\# (선택 사항) cursor-agent를 $PATH$에 추가합니다.  
\# ENV PATH="/app:${PATH}"

\# Go 앱이 8080 포트를 노출한다고 가정합니다.\[52, 57, 58\]  
\# Cloud Run은 이 포트를 자동으로 감지합니다.  
EXPOSE 8080

\# 최종 컨테이너 실행 명령어를 정의합니다.\[52, 58\]  
\# Go 바이너리가./cursor-agent 를 직접 실행하도록 코드가 작성되었다고 가정합니다.  
ENTRYPOINT \["./slack-bridge-server"\]

### **4.3. Dockerfile 빌드**

위 Dockerfile을 프로젝트 루트에 저장한 후, 로컬에서 다음 명령어로 Docker 이미지를 빌드합니다.  
docker build \-t my-slack-bridge.

## **V. 실전 배포 가이드 2: 클라우드 플랫폼 배포 및 슬랙 연동**

### **5.1. 옵션 A (비권장): $Render.com$에 Docker 이미지 배포**

$Render$는 콜드 스타트 문제 43로 권장되지 않지만, 배포가 가장 간단한 옵션입니다.

1. $Render$ 대시보드에서 'New Web Service'를 생성합니다.41  
2. Go 프로젝트가 있는 GitHub 리포지토리를 연결합니다.  
3. **핵심 설정:** 'Environment' 또는 'Language'를 'Go'가 아닌 \*\*'Docker'\*\*로 설정합니다.59  
4. $Render$가 리포지토리 루트에서 Dockerfile을 자동으로 감지합니다. 만약 경로가 다르다면 'Dockerfile Path'를 명시합니다.59  
5. 'Instance Type'에서 'Free' 등급을 선택합니다.43  
6. 배포 후 생성된 .onrender.com URL을 확보합니다. (단, 15분 후 휴면 문제를 반드시 인지해야 합니다.)

### **5.2. 옵션 B (권장): $Google Cloud Run$에 컨테이너 배포**

이 방식은 안정적이고 진정한 무료 배포를 제공합니다. $Google Cloud SDK$ (gcloud CLI) 설치 및 GCP 프로젝트 생성이 완료되었다고 가정합니다.

#### **5.2.1. Artifact Registry 활성화 및 Docker 인증**

컨테이너 이미지를 저장할 $Google Artifact Registry$ (Docker 레지스트리)를 활성화하고 Docker 클라이언트를 인증합니다.

Bash

\# Google Cloud 서비스 활성화  
gcloud services enable artifactregistry.googleapis.com  
gcloud services enable run.googleapis.com

\# 'docker'라는 이름의 Artifact Registry 저장소 생성 (리전 선택)  
gcloud artifacts repositories create docker \\  
    \--repository-format=docker \\  
    \--location=asia-northeast3 \\  
    \--description="Docker repository"

\# gcloud CLI를 Docker 인증 도우미로 설정  
gcloud auth configure-docker asia-northeast3-docker.pkg.dev

#### **5.2.2. 이미지 태그 및 푸시**

로컬에서 빌드한 이미지를 $Artifact Registry$ 경로에 맞게 태그하고 푸시합니다. ($PROJECT\_ID$는 본인의 GCP 프로젝트 ID로 대체)

Bash

\# 1\. 로컬 이미지 태그  
docker tag my-slack-bridge \\  
    asia-northeast3-docker.pkg.dev/$PROJECT\_ID/docker/my-slack-bridge:latest

\# 2\. 이미지 푸시  
docker push asia-northeast3-docker.pkg.dev/$PROJECT\_ID/docker/my-slack-bridge:latest

#### **5.2.3. Cloud Run 배포**

푸시한 이미지를 사용하여 $Cloud Run$ 서비스를 배포합니다.

Bash

gcloud run deploy slack-bridge-service \\  
    \--image asia-northeast3-docker.pkg.dev/$PROJECT\_ID/docker/my-slack-bridge:latest \\  
    \--platform managed \\  
    \--region asia-northeast3 \\  
    \--port 8080 \\  
    \--allow-unauthenticated

* \--platform managed: 완전 관리형 서버리스 환경을 사용합니다.  
* \--port 8080: $Dockerfile$에서 $EXPOSE$한 포트와 일치시킵니다.57  
* \--allow-unauthenticated: **(필수)** 슬랙과 같은 외부 서비스가 인증 없이 이 엔드포인트를 호출할 수 있도록 공개 URL을 생성합니다.

#### **5.2.4. 영구 URL 확인**

배포가 성공적으로 완료되면, gcloud CLI는 다음과 같이 .run.app으로 끝나는 영구적인 HTTPS URL을 출력합니다.  
Service \[slack-bridge-service\] revision \[slack-bridge-service-00001-abc\] has been deployed and is serving 100% of traffic at https://slack-bridge-service-xxxxxxxxxx-an.a.run.app

### **5.3. 최종 단계: 슬랙 앱에 영구 URL 등록**

1. $Google Cloud Run$에서 받은 영구 URL(예: https://...run.app)을 복사합니다.  
2. 슬랙 앱 설정 페이지('Features' \> 'Slash Commands' 또는 'Event Subscriptions')로 이동합니다.1  
3. 'Request URL' 필드에 해당 URL(및 필요한 경로, 예: /slack/events 16)을 붙여넣습니다.  
4. 설정을 저장합니다.

이 설정은 더 이상 변경할 필요가 없습니다. 이제 사용자의 슬랙 브릿지 서버는 로컬 머신과 완전히 분리되어, $Google Cloud$의 관대한 영구 무료 등급 내에서 24/7 안정적으로 작동합니다.44

## **VI. 결론 및 최종 권장 사항**

### **6.1. 옵션 요약**

사용자의 "무료 공개 URL" 요구사항을 충족하기 위한 아키텍처 옵션은 다음과 같이 요약됩니다.

* **$ngrok$ (정적 도메인):** 가장 빠르고 쉬운 설정입니다.5 하지만 로컬 머신이 24/7 실행되어야 하며, 월 1GB/20k 요청이라는 매우 엄격한 무료 제한 5을 감수해야 합니다. 빠른 데모 및 디버깅에 적합합니다.  
* **$Cloudflare Tunnel$:** 가장 강력하고 성능 좋은 터널링입니다.22 트래픽 제한이 사실상 없습니다.20 하지만 "무료"가 아니며, 도메인 구매 비용(연 $10\~$15)이 발생합니다.23  
* **$Render.com$:** Git 기반 배포가 매우 쉽습니다.41 그러나 15분 휴면(Spin-down) 정책 43으로 인한 느린 콜드 스타트 시간은 슬랙의 3초 타임아웃 요구사항을 만족시킬 수 없어, *웹훅 수신기* 용도로는 아키텍처적으로 부적합합니다.  
* **$Google Cloud Run$:** '무료' 46, '안정성'(PaaS), '성능'(빠른 콜드 스타트)을 모두 만족하는 유일한 솔루션입니다.37 유일한 단점은 Docker 및 gcloud CLI 학습 곡선이 필요하다는 점입니다.

### **6.2. 최종 권장 (멘토의 조언)**

"토이 프로젝트"의 목적이 '단순히 작동하게 하여 1시간 동안 데모'하는 것이라면, $ngrok$의 무료 정적 도메인 5을 사용하는 것이 가장 효율적입니다.

하지만 "토이 프로젝트"의 목적이 '전문적인 배포 기술을 학습'하고 '지속적으로 사용 가능한 서비스'를 만드는 것이라면, \*\*$Google Cloud Run$\*\*을 강력히 권장합니다.

$Cloud Run$을 선택하는 것은 초기 설정(Docker)의 복잡성을 감수하는 대신, Docker 60, 멀티 스테이지 빌드 49, 컨테이너 레지스트리, 서버리스 배포(Scale-to-Zero)라는 현대 클라우드 네이티브 개발의 핵심 워크플로우 전체를 *무료로* 학습하고 포트폴리오에 추가할 수 있는 가장 확실한 기회입니다. 본 보고서의 IV, V 섹션은 그 과정을 위한 완벽한 가이드입니다.

#### **참고 자료**

1. Slash Commands | Slack Developer Docs, 11월 6, 2025에 액세스, [https://docs.slack.dev/tools/java-slack-sdk/guides/slash-commands](https://docs.slack.dev/tools/java-slack-sdk/guides/slash-commands)  
2. Slack Webhook \- ngrok documentation, 11월 6, 2025에 액세스, [https://ngrok.com/docs/integrations/webhooks/slack-webhooks](https://ngrok.com/docs/integrations/webhooks/slack-webhooks)  
3. How to set up redirect url for slack authorization with ngrok \- Stack Overflow, 11월 6, 2025에 액세스, [https://stackoverflow.com/questions/71918132/how-to-set-up-redirect-url-for-slack-authorization-with-ngrok](https://stackoverflow.com/questions/71918132/how-to-set-up-redirect-url-for-slack-authorization-with-ngrok)  
4. How to expose your localhost server using Ngrok | by Reyhan \- Medium, 11월 6, 2025에 액세스, [https://reyhann.medium.com/how-to-expose-your-localhost-server-using-ngrok-9928ac2e26b8](https://reyhann.medium.com/how-to-expose-your-localhost-server-using-ngrok-9928ac2e26b8)  
5. Free Plan Limits \- ngrok documentation, 11월 6, 2025에 액세스, [https://ngrok.com/docs/pricing-limits/free-plan-limits](https://ngrok.com/docs/pricing-limits/free-plan-limits)  
6. Plans and Pricing | ngrok | API Gateway, IoT Device Gateway, Secure Tunnels for Containers, Apps & APIs, 11월 6, 2025에 액세스, [https://ngrok.com/pricing](https://ngrok.com/pricing)  
7. Open source alternatives for ngrok? : r/opensource \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/opensource/comments/19fc70u/open\_source\_alternatives\_for\_ngrok/](https://www.reddit.com/r/opensource/comments/19fc70u/open_source_alternatives_for_ngrok/)  
8. Usage Charges and Metrics in ngrok Plans, 11월 6, 2025에 액세스, [https://ngrok.com/docs/pricing-limits/how-ngrok-charges](https://ngrok.com/docs/pricing-limits/how-ngrok-charges)  
9. Building Go Apps with Cursor? Deploy Them on Fly.io, 11월 6, 2025에 액세스, [https://fly.io/go/agents/cursor](https://fly.io/go/agents/cursor)  
10. Getting Started with Cursor CLI: A Complete Guide \- Codecademy, 11월 6, 2025에 액세스, [https://www.codecademy.com/article/getting-started-with-cursor-cli](https://www.codecademy.com/article/getting-started-with-cursor-cli)  
11. Agent CLI Quickstart \- ngrok documentation, 11월 6, 2025에 액세스, [https://ngrok.com/docs/getting-started](https://ngrok.com/docs/getting-started)  
12. Set up your Go and Gin development environment \- Twilio, 11월 6, 2025에 액세스, [https://www.twilio.com/docs/usage/tutorials/how-to-set-up-your-go-and-gin-development-environment](https://www.twilio.com/docs/usage/tutorials/how-to-set-up-your-go-and-gin-development-environment)  
13. ngrok Step-by-Step Guide: Easily Share Your Local Server \- SitePoint, 11월 6, 2025에 액세스, [https://www.sitepoint.com/use-ngrok-test-local-site/](https://www.sitepoint.com/use-ngrok-test-local-site/)  
14. ngrok Agent Command Line Interface (CLI), 11월 6, 2025에 액세스, [https://ngrok.com/docs/agent/cli](https://ngrok.com/docs/agent/cli)  
15. ngrok Agent \- ngrok documentation, 11월 6, 2025에 액세스, [https://ngrok.com/docs/agent](https://ngrok.com/docs/agent)  
16. Why slack slash command returns "http\_client\_error" \- Stack Overflow, 11월 6, 2025에 액세스, [https://stackoverflow.com/questions/60010101/why-slack-slash-command-returns-http-client-error](https://stackoverflow.com/questions/60010101/why-slack-slash-command-returns-http-client-error)  
17. Pricing and Limits \- ngrok documentation, 11월 6, 2025에 액세스, [https://ngrok.com/docs/pricing-limits](https://ngrok.com/docs/pricing-limits)  
18. Ngrok vs Cloudflare Tunnel vs Tailscale: Complete 2025-26 \- InstaTunnel, 11월 6, 2025에 액세스, [https://instatunnel.my/blog/comparing-the-big-three-a-comprehensive-analysis-of-ngrok-cloudflare-tunnel-and-tailscale-for-modern-development-teams](https://instatunnel.my/blog/comparing-the-big-three-a-comprehensive-analysis-of-ngrok-cloudflare-tunnel-and-tailscale-for-modern-development-teams)  
19. Major Cloudflare Tunnel Limitations? \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/CloudFlare/comments/vopngp/major\_cloudflare\_tunnel\_limitations/](https://www.reddit.com/r/CloudFlare/comments/vopngp/major_cloudflare_tunnel_limitations/)  
20. Free Plan Overview \- Cloudflare, 11월 6, 2025에 액세스, [https://www.cloudflare.com/plans/free/](https://www.cloudflare.com/plans/free/)  
21. Account limits · Cloudflare One docs, 11월 6, 2025에 액세스, [https://developers.cloudflare.com/cloudflare-one/account-limits/](https://developers.cloudflare.com/cloudflare-one/account-limits/)  
22. Secure Tunneling Explained: Ngrok vs Cloudflared \- DEV Community, 11월 6, 2025에 액세스, [https://dev.to/aryan\_shourie/secure-tunneling-explained-ngrok-vs-cloudflared-mcl](https://dev.to/aryan_shourie/secure-tunneling-explained-ngrok-vs-cloudflared-mcl)  
23. Cloudflare tunnels as a much cheaper alternative to Ngrok : r/webdev \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/webdev/comments/1ckkosb/cloudflare\_tunnels\_as\_a\_much\_cheaper\_alternative/](https://www.reddit.com/r/webdev/comments/1ckkosb/cloudflare_tunnels_as_a_much_cheaper_alternative/)  
24. Quick Tunnels · Cloudflare One docs, 11월 6, 2025에 액세스, [https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/do-more-with-tunnels/trycloudflare/](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/do-more-with-tunnels/trycloudflare/)  
25. anderspitman/awesome-tunneling: List of ngrok/Cloudflare Tunnel alternatives and other tunneling software and services. Focus on self-hosting. \- GitHub, 11월 6, 2025에 액세스, [https://github.com/anderspitman/awesome-tunneling](https://github.com/anderspitman/awesome-tunneling)  
26. Ngrok Alternatives for Developers: Exploring Your Options \- PubNub, 11월 6, 2025에 액세스, [https://www.pubnub.com/guides/ngrok-alternatives/](https://www.pubnub.com/guides/ngrok-alternatives/)  
27. Top 10 Ngrok alternatives in 2025 \- Pinggy, 11월 6, 2025에 액세스, [https://pinggy.io/blog/best\_ngrok\_alternatives/](https://pinggy.io/blog/best_ngrok_alternatives/)  
28. Alternatives to Ngrok : r/node \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/node/comments/yd99nb/alternatives\_to\_ngrok/](https://www.reddit.com/r/node/comments/yd99nb/alternatives_to_ngrok/)  
29. Ngrok vs. Localtunnel: The Simplicity of Open-Source Tunneling | by InstaTunnel, 11월 6, 2025에 액세스, [https://medium.com/@instatunnel/ngrok-vs-localtunnel-the-simplicity-of-open-source-tunneling-d21a253e4d67](https://medium.com/@instatunnel/ngrok-vs-localtunnel-the-simplicity-of-open-source-tunneling-d21a253e4d67)  
30. alternative of ngrok localtunnel : r/selfhosted \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/selfhosted/comments/1968up6/alternative\_of\_ngrok\_localtunnel/](https://www.reddit.com/r/selfhosted/comments/1968up6/alternative_of_ngrok_localtunnel/)  
31. Free ngrok alternative that supports local domain names AND has a web UI? \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/homelab/comments/1hb4z7f/free\_ngrok\_alternative\_that\_supports\_local\_domain/](https://www.reddit.com/r/homelab/comments/1hb4z7f/free_ngrok_alternative_that_supports_local_domain/)  
32. Top 10 Free PaaS Platforms of 2025: A Developer's Guide, 11월 6, 2025에 액세스, [https://blog.back4app.com/free-paas/](https://blog.back4app.com/free-paas/)  
33. Railway vs Render (2025): Which cloud platform fits your workflow better | Blog \- Northflank, 11월 6, 2025에 액세스, [https://northflank.com/blog/railway-vs-render](https://northflank.com/blog/railway-vs-render)  
34. Railway Pricing and Plans, 11월 6, 2025에 액세스, [https://railway.com/pricing](https://railway.com/pricing)  
35. What is Railway's pricing structure and free options? \- LinkGo, 11월 6, 2025에 액세스, [https://linkgo.dev/faq/railways-pricing-structure-and-free-options](https://linkgo.dev/faq/railways-pricing-structure-and-free-options)  
36. Railway.app free plan usage advice or any alternatives(as a student). : r/node \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/node/comments/1fbpevm/railwayapp\_free\_plan\_usage\_advice\_or\_any/](https://www.reddit.com/r/node/comments/1fbpevm/railwayapp_free_plan_usage_advice_or_any/)  
37. Recommendations for hosting a Go app in 2024 : r/golang \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/golang/comments/1fvdtf7/recommendations\_for\_hosting\_a\_go\_app\_in\_2024/](https://www.reddit.com/r/golang/comments/1fvdtf7/recommendations_for_hosting_a_go_app_in_2024/)  
38. Fly.io Resource Pricing · Fly Docs, 11월 6, 2025에 액세스, [https://fly.io/docs/about/pricing/](https://fly.io/docs/about/pricing/)  
39. Pricing \- Fly.io, 11월 6, 2025에 액세스, [https://fly.io/pricing/](https://fly.io/pricing/)  
40. Free tier is dead? \- billing \- Fly.io Community, 11월 6, 2025에 액세스, [https://community.fly.io/t/free-tier-is-dead/20651](https://community.fly.io/t/free-tier-is-dead/20651)  
41. Web Services – Render Docs, 11월 6, 2025에 액세스, [https://render.com/docs/web-services](https://render.com/docs/web-services)  
42. Deploy a Go Web Server on Render, 11월 6, 2025에 액세스, [https://render.com/docs/deploy-go-nethttp](https://render.com/docs/deploy-go-nethttp)  
43. Deploy for Free – Render Docs, 11월 6, 2025에 액세스, [https://render.com/docs/free](https://render.com/docs/free)  
44. Free Trial and Free Tier Services and Products \- Google Cloud, 11월 6, 2025에 액세스, [https://cloud.google.com/free](https://cloud.google.com/free)  
45. Host a application for free forever using Go? : r/golang \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/golang/comments/zuogol/host\_a\_application\_for\_free\_forever\_using\_go/](https://www.reddit.com/r/golang/comments/zuogol/host_a_application_for_free_forever_using_go/)  
46. Cloud Run pricing | Google Cloud, 11월 6, 2025에 액세스, [https://cloud.google.com/run/pricing](https://cloud.google.com/run/pricing)  
47. Installation | Cursor Docs, 11월 6, 2025에 액세스, [https://cursor.com/docs/cli/installation](https://cursor.com/docs/cli/installation)  
48. Cursor Agent CLI, 11월 6, 2025에 액세스, [https://cursor.com/blog/cli](https://cursor.com/blog/cli)  
49. Multi-stage builds \- Docker Docs, 11월 6, 2025에 액세스, [https://docs.docker.com/build/building/multi-stage/](https://docs.docker.com/build/building/multi-stage/)  
50. Building best practices \- Docker Docs, 11월 6, 2025에 액세스, [https://docs.docker.com/build/building/best-practices/](https://docs.docker.com/build/building/best-practices/)  
51. Use Multi-Stage Docker Builds For Statically-Linked Rust Binaries \- DEV Community, 11월 6, 2025에 액세스, [https://dev.to/deciduously/use-multi-stage-docker-builds-for-statically-linked-rust-binaries-3jgd](https://dev.to/deciduously/use-multi-stage-docker-builds-for-statically-linked-rust-binaries-3jgd)  
52. Where to put the compiled Go binary? \- Stack Overflow, 11월 6, 2025에 액세스, [https://stackoverflow.com/questions/61388759/where-to-put-the-compiled-go-binary](https://stackoverflow.com/questions/61388759/where-to-put-the-compiled-go-binary)  
53. Deploy with a Dockerfile \- Fly.io, 11월 6, 2025에 액세스, [https://fly.io/docs/languages-and-frameworks/dockerfile/](https://fly.io/docs/languages-and-frameworks/dockerfile/)  
54. Docker on Render, 11월 6, 2025에 액세스, [https://render.com/docs/docker](https://render.com/docs/docker)  
55. Build your Go image \- Docker Docs, 11월 6, 2025에 액세스, [https://docs.docker.com/guides/golang/build-images/](https://docs.docker.com/guides/golang/build-images/)  
56. Is fly.io ridiculously expensive? : r/elixir \- Reddit, 11월 6, 2025에 액세스, [https://www.reddit.com/r/elixir/comments/1h8ajm2/is\_flyio\_ridiculously\_expensive/](https://www.reddit.com/r/elixir/comments/1h8ajm2/is_flyio_ridiculously_expensive/)